
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Domain
 * 
 */
export type Domain = $Result.DefaultSelection<Prisma.$DomainPayload>
/**
 * Model EmailAccount
 * 
 */
export type EmailAccount = $Result.DefaultSelection<Prisma.$EmailAccountPayload>
/**
 * Model Email
 * 
 */
export type Email = $Result.DefaultSelection<Prisma.$EmailPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketAttachment
 * 
 */
export type TicketAttachment = $Result.DefaultSelection<Prisma.$TicketAttachmentPayload>
/**
 * Model TicketMessage
 * 
 */
export type TicketMessage = $Result.DefaultSelection<Prisma.$TicketMessagePayload>
/**
 * Model EmailAttachment
 * 
 */
export type EmailAttachment = $Result.DefaultSelection<Prisma.$EmailAttachmentPayload>
/**
 * Model OAuthApplication
 * 
 */
export type OAuthApplication = $Result.DefaultSelection<Prisma.$OAuthApplicationPayload>
/**
 * Model OAuthAuthCode
 * 
 */
export type OAuthAuthCode = $Result.DefaultSelection<Prisma.$OAuthAuthCodePayload>
/**
 * Model OAuthAccessToken
 * 
 */
export type OAuthAccessToken = $Result.DefaultSelection<Prisma.$OAuthAccessTokenPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.domain`: Exposes CRUD operations for the **Domain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Domains
    * const domains = await prisma.domain.findMany()
    * ```
    */
  get domain(): Prisma.DomainDelegate<ExtArgs>;

  /**
   * `prisma.emailAccount`: Exposes CRUD operations for the **EmailAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAccounts
    * const emailAccounts = await prisma.emailAccount.findMany()
    * ```
    */
  get emailAccount(): Prisma.EmailAccountDelegate<ExtArgs>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **Email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.EmailDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs>;

  /**
   * `prisma.ticketAttachment`: Exposes CRUD operations for the **TicketAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketAttachments
    * const ticketAttachments = await prisma.ticketAttachment.findMany()
    * ```
    */
  get ticketAttachment(): Prisma.TicketAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.ticketMessage`: Exposes CRUD operations for the **TicketMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketMessages
    * const ticketMessages = await prisma.ticketMessage.findMany()
    * ```
    */
  get ticketMessage(): Prisma.TicketMessageDelegate<ExtArgs>;

  /**
   * `prisma.emailAttachment`: Exposes CRUD operations for the **EmailAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAttachments
    * const emailAttachments = await prisma.emailAttachment.findMany()
    * ```
    */
  get emailAttachment(): Prisma.EmailAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.oAuthApplication`: Exposes CRUD operations for the **OAuthApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthApplications
    * const oAuthApplications = await prisma.oAuthApplication.findMany()
    * ```
    */
  get oAuthApplication(): Prisma.OAuthApplicationDelegate<ExtArgs>;

  /**
   * `prisma.oAuthAuthCode`: Exposes CRUD operations for the **OAuthAuthCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthAuthCodes
    * const oAuthAuthCodes = await prisma.oAuthAuthCode.findMany()
    * ```
    */
  get oAuthAuthCode(): Prisma.OAuthAuthCodeDelegate<ExtArgs>;

  /**
   * `prisma.oAuthAccessToken`: Exposes CRUD operations for the **OAuthAccessToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthAccessTokens
    * const oAuthAccessTokens = await prisma.oAuthAccessToken.findMany()
    * ```
    */
  get oAuthAccessToken(): Prisma.OAuthAccessTokenDelegate<ExtArgs>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Domain: 'Domain',
    EmailAccount: 'EmailAccount',
    Email: 'Email',
    Plan: 'Plan',
    Subscription: 'Subscription',
    Invoice: 'Invoice',
    Ticket: 'Ticket',
    TicketAttachment: 'TicketAttachment',
    TicketMessage: 'TicketMessage',
    EmailAttachment: 'EmailAttachment',
    OAuthApplication: 'OAuthApplication',
    OAuthAuthCode: 'OAuthAuthCode',
    OAuthAccessToken: 'OAuthAccessToken',
    PromoCode: 'PromoCode',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "domain" | "emailAccount" | "email" | "plan" | "subscription" | "invoice" | "ticket" | "ticketAttachment" | "ticketMessage" | "emailAttachment" | "oAuthApplication" | "oAuthAuthCode" | "oAuthAccessToken" | "promoCode" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Domain: {
        payload: Prisma.$DomainPayload<ExtArgs>
        fields: Prisma.DomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findFirst: {
            args: Prisma.DomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          findMany: {
            args: Prisma.DomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>[]
          }
          create: {
            args: Prisma.DomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          createMany: {
            args: Prisma.DomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          update: {
            args: Prisma.DomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          deleteMany: {
            args: Prisma.DomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPayload>
          }
          aggregate: {
            args: Prisma.DomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomain>
          }
          groupBy: {
            args: Prisma.DomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainCountArgs<ExtArgs>
            result: $Utils.Optional<DomainCountAggregateOutputType> | number
          }
        }
      }
      EmailAccount: {
        payload: Prisma.$EmailAccountPayload<ExtArgs>
        fields: Prisma.EmailAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          findFirst: {
            args: Prisma.EmailAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          findMany: {
            args: Prisma.EmailAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>[]
          }
          create: {
            args: Prisma.EmailAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          createMany: {
            args: Prisma.EmailAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          update: {
            args: Prisma.EmailAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          deleteMany: {
            args: Prisma.EmailAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          aggregate: {
            args: Prisma.EmailAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAccount>
          }
          groupBy: {
            args: Prisma.EmailAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAccountCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAccountCountAggregateOutputType> | number
          }
        }
      }
      Email: {
        payload: Prisma.$EmailPayload<ExtArgs>
        fields: Prisma.EmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findFirst: {
            args: Prisma.EmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findMany: {
            args: Prisma.EmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          create: {
            args: Prisma.EmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          createMany: {
            args: Prisma.EmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          update: {
            args: Prisma.EmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          deleteMany: {
            args: Prisma.EmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.EmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketAttachment: {
        payload: Prisma.$TicketAttachmentPayload<ExtArgs>
        fields: Prisma.TicketAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TicketAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findMany: {
            args: Prisma.TicketAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          create: {
            args: Prisma.TicketAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          createMany: {
            args: Prisma.TicketAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          update: {
            args: Prisma.TicketAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TicketAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TicketAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketAttachment>
          }
          groupBy: {
            args: Prisma.TicketAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentCountAggregateOutputType> | number
          }
        }
      }
      TicketMessage: {
        payload: Prisma.$TicketMessagePayload<ExtArgs>
        fields: Prisma.TicketMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findFirst: {
            args: Prisma.TicketMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findMany: {
            args: Prisma.TicketMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          create: {
            args: Prisma.TicketMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          createMany: {
            args: Prisma.TicketMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          update: {
            args: Prisma.TicketMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          deleteMany: {
            args: Prisma.TicketMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          aggregate: {
            args: Prisma.TicketMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketMessage>
          }
          groupBy: {
            args: Prisma.TicketMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageCountAggregateOutputType> | number
          }
        }
      }
      EmailAttachment: {
        payload: Prisma.$EmailAttachmentPayload<ExtArgs>
        fields: Prisma.EmailAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          findFirst: {
            args: Prisma.EmailAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          findMany: {
            args: Prisma.EmailAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>[]
          }
          create: {
            args: Prisma.EmailAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          createMany: {
            args: Prisma.EmailAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          update: {
            args: Prisma.EmailAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.EmailAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          aggregate: {
            args: Prisma.EmailAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAttachment>
          }
          groupBy: {
            args: Prisma.EmailAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAttachmentCountAggregateOutputType> | number
          }
        }
      }
      OAuthApplication: {
        payload: Prisma.$OAuthApplicationPayload<ExtArgs>
        fields: Prisma.OAuthApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload>
          }
          findFirst: {
            args: Prisma.OAuthApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload>
          }
          findMany: {
            args: Prisma.OAuthApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload>[]
          }
          create: {
            args: Prisma.OAuthApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload>
          }
          createMany: {
            args: Prisma.OAuthApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OAuthApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload>
          }
          update: {
            args: Prisma.OAuthApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload>
          }
          deleteMany: {
            args: Prisma.OAuthApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthApplicationPayload>
          }
          aggregate: {
            args: Prisma.OAuthApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthApplication>
          }
          groupBy: {
            args: Prisma.OAuthApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthApplicationCountAggregateOutputType> | number
          }
        }
      }
      OAuthAuthCode: {
        payload: Prisma.$OAuthAuthCodePayload<ExtArgs>
        fields: Prisma.OAuthAuthCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthAuthCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthAuthCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload>
          }
          findFirst: {
            args: Prisma.OAuthAuthCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthAuthCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload>
          }
          findMany: {
            args: Prisma.OAuthAuthCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload>[]
          }
          create: {
            args: Prisma.OAuthAuthCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload>
          }
          createMany: {
            args: Prisma.OAuthAuthCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OAuthAuthCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload>
          }
          update: {
            args: Prisma.OAuthAuthCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload>
          }
          deleteMany: {
            args: Prisma.OAuthAuthCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthAuthCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthAuthCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAuthCodePayload>
          }
          aggregate: {
            args: Prisma.OAuthAuthCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthAuthCode>
          }
          groupBy: {
            args: Prisma.OAuthAuthCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthAuthCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthAuthCodeCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthAuthCodeCountAggregateOutputType> | number
          }
        }
      }
      OAuthAccessToken: {
        payload: Prisma.$OAuthAccessTokenPayload<ExtArgs>
        fields: Prisma.OAuthAccessTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthAccessTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthAccessTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload>
          }
          findFirst: {
            args: Prisma.OAuthAccessTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthAccessTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload>
          }
          findMany: {
            args: Prisma.OAuthAccessTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload>[]
          }
          create: {
            args: Prisma.OAuthAccessTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload>
          }
          createMany: {
            args: Prisma.OAuthAccessTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OAuthAccessTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload>
          }
          update: {
            args: Prisma.OAuthAccessTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload>
          }
          deleteMany: {
            args: Prisma.OAuthAccessTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthAccessTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthAccessTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccessTokenPayload>
          }
          aggregate: {
            args: Prisma.OAuthAccessTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthAccessToken>
          }
          groupBy: {
            args: Prisma.OAuthAccessTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthAccessTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthAccessTokenCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthAccessTokenCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Domain: number
    EmailAccounts: number
    subscriptions: number
    invoices: number
    tickets: number
    ticketMessages: number
    oauthApplications: number
    oauthAuthCodes: number
    oauthAccessTokens: number
    createdPromoCodes: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Domain?: boolean | UserCountOutputTypeCountDomainArgs
    EmailAccounts?: boolean | UserCountOutputTypeCountEmailAccountsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    ticketMessages?: boolean | UserCountOutputTypeCountTicketMessagesArgs
    oauthApplications?: boolean | UserCountOutputTypeCountOauthApplicationsArgs
    oauthAuthCodes?: boolean | UserCountOutputTypeCountOauthAuthCodesArgs
    oauthAccessTokens?: boolean | UserCountOutputTypeCountOauthAccessTokensArgs
    createdPromoCodes?: boolean | UserCountOutputTypeCountCreatedPromoCodesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthAuthCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAuthCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAccessTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type DomainCountOutputType
   */

  export type DomainCountOutputType = {
    emailAccounts: number
  }

  export type DomainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailAccounts?: boolean | DomainCountOutputTypeCountEmailAccountsArgs
  }

  // Custom InputTypes
  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCountOutputType
     */
    select?: DomainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainCountOutputType without action
   */
  export type DomainCountOutputTypeCountEmailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
  }


  /**
   * Count Type EmailAccountCountOutputType
   */

  export type EmailAccountCountOutputType = {
    emails: number
  }

  export type EmailAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | EmailAccountCountOutputTypeCountEmailsArgs
  }

  // Custom InputTypes
  /**
   * EmailAccountCountOutputType without action
   */
  export type EmailAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccountCountOutputType
     */
    select?: EmailAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailAccountCountOutputType without action
   */
  export type EmailAccountCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * Count Type EmailCountOutputType
   */

  export type EmailCountOutputType = {
    attachments: number
  }

  export type EmailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | EmailCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCountOutputType
     */
    select?: EmailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAttachmentWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    subscriptions: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    attachments: number
    messages: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | TicketCountOutputTypeCountAttachmentsArgs
    messages?: boolean | TicketCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
  }


  /**
   * Count Type OAuthApplicationCountOutputType
   */

  export type OAuthApplicationCountOutputType = {
    authCodes: number
    accessTokens: number
  }

  export type OAuthApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authCodes?: boolean | OAuthApplicationCountOutputTypeCountAuthCodesArgs
    accessTokens?: boolean | OAuthApplicationCountOutputTypeCountAccessTokensArgs
  }

  // Custom InputTypes
  /**
   * OAuthApplicationCountOutputType without action
   */
  export type OAuthApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplicationCountOutputType
     */
    select?: OAuthApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OAuthApplicationCountOutputType without action
   */
  export type OAuthApplicationCountOutputTypeCountAuthCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAuthCodeWhereInput
  }

  /**
   * OAuthApplicationCountOutputType without action
   */
  export type OAuthApplicationCountOutputTypeCountAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAccessTokenWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    credits: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    credits: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    phone: string | null
    paymentMethod: string | null
    paymentDetails: string | null
    recoveryEmail: string | null
    recoveryPhone: string | null
    recoveryPhoneCountryCode: string | null
    allowEmailRecovery: boolean | null
    allowPhoneRecovery: boolean | null
    allowQRLogin: boolean | null
    recoveryPhrase: string | null
    allowRecoveryPhrase: boolean | null
    allowDeviceRecovery: boolean | null
    recoveryFileHash: string | null
    preferences: string | null
    credits: number | null
    appliedGiftCodes: string | null
    twoPasswordMode: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorMethod: string | null
    twoFactorSecret: string | null
    emergencyContacts: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    phone: string | null
    paymentMethod: string | null
    paymentDetails: string | null
    recoveryEmail: string | null
    recoveryPhone: string | null
    recoveryPhoneCountryCode: string | null
    allowEmailRecovery: boolean | null
    allowPhoneRecovery: boolean | null
    allowQRLogin: boolean | null
    recoveryPhrase: string | null
    allowRecoveryPhrase: boolean | null
    allowDeviceRecovery: boolean | null
    recoveryFileHash: string | null
    preferences: string | null
    credits: number | null
    appliedGiftCodes: string | null
    twoPasswordMode: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorMethod: string | null
    twoFactorSecret: string | null
    emergencyContacts: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    phone: number
    paymentMethod: number
    paymentDetails: number
    recoveryEmail: number
    recoveryPhone: number
    recoveryPhoneCountryCode: number
    allowEmailRecovery: number
    allowPhoneRecovery: number
    allowQRLogin: number
    recoveryPhrase: number
    allowRecoveryPhrase: number
    allowDeviceRecovery: number
    recoveryFileHash: number
    preferences: number
    credits: number
    appliedGiftCodes: number
    twoPasswordMode: number
    twoFactorEnabled: number
    twoFactorMethod: number
    twoFactorSecret: number
    emergencyContacts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    credits?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    credits?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    paymentMethod?: true
    paymentDetails?: true
    recoveryEmail?: true
    recoveryPhone?: true
    recoveryPhoneCountryCode?: true
    allowEmailRecovery?: true
    allowPhoneRecovery?: true
    allowQRLogin?: true
    recoveryPhrase?: true
    allowRecoveryPhrase?: true
    allowDeviceRecovery?: true
    recoveryFileHash?: true
    preferences?: true
    credits?: true
    appliedGiftCodes?: true
    twoPasswordMode?: true
    twoFactorEnabled?: true
    twoFactorMethod?: true
    twoFactorSecret?: true
    emergencyContacts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    paymentMethod?: true
    paymentDetails?: true
    recoveryEmail?: true
    recoveryPhone?: true
    recoveryPhoneCountryCode?: true
    allowEmailRecovery?: true
    allowPhoneRecovery?: true
    allowQRLogin?: true
    recoveryPhrase?: true
    allowRecoveryPhrase?: true
    allowDeviceRecovery?: true
    recoveryFileHash?: true
    preferences?: true
    credits?: true
    appliedGiftCodes?: true
    twoPasswordMode?: true
    twoFactorEnabled?: true
    twoFactorMethod?: true
    twoFactorSecret?: true
    emergencyContacts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    paymentMethod?: true
    paymentDetails?: true
    recoveryEmail?: true
    recoveryPhone?: true
    recoveryPhoneCountryCode?: true
    allowEmailRecovery?: true
    allowPhoneRecovery?: true
    allowQRLogin?: true
    recoveryPhrase?: true
    allowRecoveryPhrase?: true
    allowDeviceRecovery?: true
    recoveryFileHash?: true
    preferences?: true
    credits?: true
    appliedGiftCodes?: true
    twoPasswordMode?: true
    twoFactorEnabled?: true
    twoFactorMethod?: true
    twoFactorSecret?: true
    emergencyContacts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    role: string
    phone: string | null
    paymentMethod: string | null
    paymentDetails: string | null
    recoveryEmail: string | null
    recoveryPhone: string | null
    recoveryPhoneCountryCode: string | null
    allowEmailRecovery: boolean
    allowPhoneRecovery: boolean
    allowQRLogin: boolean
    recoveryPhrase: string | null
    allowRecoveryPhrase: boolean
    allowDeviceRecovery: boolean
    recoveryFileHash: string | null
    preferences: string | null
    credits: number
    appliedGiftCodes: string | null
    twoPasswordMode: boolean
    twoFactorEnabled: boolean
    twoFactorMethod: string | null
    twoFactorSecret: string | null
    emergencyContacts: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    recoveryEmail?: boolean
    recoveryPhone?: boolean
    recoveryPhoneCountryCode?: boolean
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: boolean
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: boolean
    preferences?: boolean
    credits?: boolean
    appliedGiftCodes?: boolean
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: boolean
    twoFactorSecret?: boolean
    emergencyContacts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Domain?: boolean | User$DomainArgs<ExtArgs>
    EmailAccounts?: boolean | User$EmailAccountsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    ticketMessages?: boolean | User$ticketMessagesArgs<ExtArgs>
    oauthApplications?: boolean | User$oauthApplicationsArgs<ExtArgs>
    oauthAuthCodes?: boolean | User$oauthAuthCodesArgs<ExtArgs>
    oauthAccessTokens?: boolean | User$oauthAccessTokensArgs<ExtArgs>
    createdPromoCodes?: boolean | User$createdPromoCodesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    recoveryEmail?: boolean
    recoveryPhone?: boolean
    recoveryPhoneCountryCode?: boolean
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: boolean
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: boolean
    preferences?: boolean
    credits?: boolean
    appliedGiftCodes?: boolean
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: boolean
    twoFactorSecret?: boolean
    emergencyContacts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Domain?: boolean | User$DomainArgs<ExtArgs>
    EmailAccounts?: boolean | User$EmailAccountsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    ticketMessages?: boolean | User$ticketMessagesArgs<ExtArgs>
    oauthApplications?: boolean | User$oauthApplicationsArgs<ExtArgs>
    oauthAuthCodes?: boolean | User$oauthAuthCodesArgs<ExtArgs>
    oauthAccessTokens?: boolean | User$oauthAccessTokensArgs<ExtArgs>
    createdPromoCodes?: boolean | User$createdPromoCodesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Domain: Prisma.$DomainPayload<ExtArgs>[]
      EmailAccounts: Prisma.$EmailAccountPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      ticketMessages: Prisma.$TicketMessagePayload<ExtArgs>[]
      oauthApplications: Prisma.$OAuthApplicationPayload<ExtArgs>[]
      oauthAuthCodes: Prisma.$OAuthAuthCodePayload<ExtArgs>[]
      oauthAccessTokens: Prisma.$OAuthAccessTokenPayload<ExtArgs>[]
      createdPromoCodes: Prisma.$PromoCodePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      role: string
      phone: string | null
      paymentMethod: string | null
      paymentDetails: string | null
      recoveryEmail: string | null
      recoveryPhone: string | null
      recoveryPhoneCountryCode: string | null
      allowEmailRecovery: boolean
      allowPhoneRecovery: boolean
      allowQRLogin: boolean
      recoveryPhrase: string | null
      allowRecoveryPhrase: boolean
      allowDeviceRecovery: boolean
      recoveryFileHash: string | null
      preferences: string | null
      credits: number
      appliedGiftCodes: string | null
      twoPasswordMode: boolean
      twoFactorEnabled: boolean
      twoFactorMethod: string | null
      twoFactorSecret: string | null
      emergencyContacts: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Domain<T extends User$DomainArgs<ExtArgs> = {}>(args?: Subset<T, User$DomainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findMany"> | Null>
    EmailAccounts<T extends User$EmailAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    ticketMessages<T extends User$ticketMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany"> | Null>
    oauthApplications<T extends User$oauthApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    oauthAuthCodes<T extends User$oauthAuthCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthAuthCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "findMany"> | Null>
    oauthAccessTokens<T extends User$oauthAccessTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthAccessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "findMany"> | Null>
    createdPromoCodes<T extends User$createdPromoCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPromoCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly paymentMethod: FieldRef<"User", 'String'>
    readonly paymentDetails: FieldRef<"User", 'String'>
    readonly recoveryEmail: FieldRef<"User", 'String'>
    readonly recoveryPhone: FieldRef<"User", 'String'>
    readonly recoveryPhoneCountryCode: FieldRef<"User", 'String'>
    readonly allowEmailRecovery: FieldRef<"User", 'Boolean'>
    readonly allowPhoneRecovery: FieldRef<"User", 'Boolean'>
    readonly allowQRLogin: FieldRef<"User", 'Boolean'>
    readonly recoveryPhrase: FieldRef<"User", 'String'>
    readonly allowRecoveryPhrase: FieldRef<"User", 'Boolean'>
    readonly allowDeviceRecovery: FieldRef<"User", 'Boolean'>
    readonly recoveryFileHash: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'String'>
    readonly credits: FieldRef<"User", 'Float'>
    readonly appliedGiftCodes: FieldRef<"User", 'String'>
    readonly twoPasswordMode: FieldRef<"User", 'Boolean'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorMethod: FieldRef<"User", 'String'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly emergencyContacts: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.Domain
   */
  export type User$DomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    where?: DomainWhereInput
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    cursor?: DomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * User.EmailAccounts
   */
  export type User$EmailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    cursor?: EmailAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticketMessages
   */
  export type User$ticketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    cursor?: TicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * User.oauthApplications
   */
  export type User$oauthApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    where?: OAuthApplicationWhereInput
    orderBy?: OAuthApplicationOrderByWithRelationInput | OAuthApplicationOrderByWithRelationInput[]
    cursor?: OAuthApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthApplicationScalarFieldEnum | OAuthApplicationScalarFieldEnum[]
  }

  /**
   * User.oauthAuthCodes
   */
  export type User$oauthAuthCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    where?: OAuthAuthCodeWhereInput
    orderBy?: OAuthAuthCodeOrderByWithRelationInput | OAuthAuthCodeOrderByWithRelationInput[]
    cursor?: OAuthAuthCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAuthCodeScalarFieldEnum | OAuthAuthCodeScalarFieldEnum[]
  }

  /**
   * User.oauthAccessTokens
   */
  export type User$oauthAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    where?: OAuthAccessTokenWhereInput
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    cursor?: OAuthAccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }

  /**
   * User.createdPromoCodes
   */
  export type User$createdPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    cursor?: PromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Domain
   */

  export type AggregateDomain = {
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  export type DomainAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    smtpPort: number | null
  }

  export type DomainSumAggregateOutputType = {
    id: number | null
    userId: number | null
    smtpPort: number | null
  }

  export type DomainMinAggregateOutputType = {
    id: number | null
    domainName: string | null
    userId: number | null
    dnsVerified: boolean | null
    mxRecord: string | null
    spfRecord: string | null
    dkimRecord: string | null
    dmarcRecord: string | null
    lastDnsCheck: Date | null
    smtpProvider: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    smtpApiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainMaxAggregateOutputType = {
    id: number | null
    domainName: string | null
    userId: number | null
    dnsVerified: boolean | null
    mxRecord: string | null
    spfRecord: string | null
    dkimRecord: string | null
    dmarcRecord: string | null
    lastDnsCheck: Date | null
    smtpProvider: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    smtpApiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainCountAggregateOutputType = {
    id: number
    domainName: number
    userId: number
    dnsVerified: number
    mxRecord: number
    spfRecord: number
    dkimRecord: number
    dmarcRecord: number
    lastDnsCheck: number
    smtpProvider: number
    smtpHost: number
    smtpPort: number
    smtpUser: number
    smtpPassword: number
    smtpApiKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainAvgAggregateInputType = {
    id?: true
    userId?: true
    smtpPort?: true
  }

  export type DomainSumAggregateInputType = {
    id?: true
    userId?: true
    smtpPort?: true
  }

  export type DomainMinAggregateInputType = {
    id?: true
    domainName?: true
    userId?: true
    dnsVerified?: true
    mxRecord?: true
    spfRecord?: true
    dkimRecord?: true
    dmarcRecord?: true
    lastDnsCheck?: true
    smtpProvider?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    smtpApiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainMaxAggregateInputType = {
    id?: true
    domainName?: true
    userId?: true
    dnsVerified?: true
    mxRecord?: true
    spfRecord?: true
    dkimRecord?: true
    dmarcRecord?: true
    lastDnsCheck?: true
    smtpProvider?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    smtpApiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainCountAggregateInputType = {
    id?: true
    domainName?: true
    userId?: true
    dnsVerified?: true
    mxRecord?: true
    spfRecord?: true
    dkimRecord?: true
    dmarcRecord?: true
    lastDnsCheck?: true
    smtpProvider?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    smtpApiKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domain to aggregate.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Domains
    **/
    _count?: true | DomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMaxAggregateInputType
  }

  export type GetDomainAggregateType<T extends DomainAggregateArgs> = {
        [P in keyof T & keyof AggregateDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomain[P]>
      : GetScalarType<T[P], AggregateDomain[P]>
  }




  export type DomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainWhereInput
    orderBy?: DomainOrderByWithAggregationInput | DomainOrderByWithAggregationInput[]
    by: DomainScalarFieldEnum[] | DomainScalarFieldEnum
    having?: DomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCountAggregateInputType | true
    _avg?: DomainAvgAggregateInputType
    _sum?: DomainSumAggregateInputType
    _min?: DomainMinAggregateInputType
    _max?: DomainMaxAggregateInputType
  }

  export type DomainGroupByOutputType = {
    id: number
    domainName: string
    userId: number
    dnsVerified: boolean
    mxRecord: string | null
    spfRecord: string | null
    dkimRecord: string | null
    dmarcRecord: string | null
    lastDnsCheck: Date | null
    smtpProvider: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    smtpApiKey: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: DomainCountAggregateOutputType | null
    _avg: DomainAvgAggregateOutputType | null
    _sum: DomainSumAggregateOutputType | null
    _min: DomainMinAggregateOutputType | null
    _max: DomainMaxAggregateOutputType | null
  }

  type GetDomainGroupByPayload<T extends DomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainGroupByOutputType[P]>
            : GetScalarType<T[P], DomainGroupByOutputType[P]>
        }
      >
    >


  export type DomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainName?: boolean
    userId?: boolean
    dnsVerified?: boolean
    mxRecord?: boolean
    spfRecord?: boolean
    dkimRecord?: boolean
    dmarcRecord?: boolean
    lastDnsCheck?: boolean
    smtpProvider?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpApiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    emailAccounts?: boolean | Domain$emailAccountsArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domain"]>


  export type DomainSelectScalar = {
    id?: boolean
    domainName?: boolean
    userId?: boolean
    dnsVerified?: boolean
    mxRecord?: boolean
    spfRecord?: boolean
    dkimRecord?: boolean
    dmarcRecord?: boolean
    lastDnsCheck?: boolean
    smtpProvider?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpApiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    emailAccounts?: boolean | Domain$emailAccountsArgs<ExtArgs>
    _count?: boolean | DomainCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Domain"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      emailAccounts: Prisma.$EmailAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      domainName: string
      userId: number
      dnsVerified: boolean
      mxRecord: string | null
      spfRecord: string | null
      dkimRecord: string | null
      dmarcRecord: string | null
      lastDnsCheck: Date | null
      smtpProvider: string | null
      smtpHost: string | null
      smtpPort: number | null
      smtpUser: string | null
      smtpPassword: string | null
      smtpApiKey: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["domain"]>
    composites: {}
  }

  type DomainGetPayload<S extends boolean | null | undefined | DomainDefaultArgs> = $Result.GetResult<Prisma.$DomainPayload, S>

  type DomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DomainFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DomainCountAggregateInputType | true
    }

  export interface DomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Domain'], meta: { name: 'Domain' } }
    /**
     * Find zero or one Domain that matches the filter.
     * @param {DomainFindUniqueArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainFindUniqueArgs>(args: SelectSubset<T, DomainFindUniqueArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Domain that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DomainFindUniqueOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Domain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainFindFirstArgs>(args?: SelectSubset<T, DomainFindFirstArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Domain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindFirstOrThrowArgs} args - Arguments to find a Domain
     * @example
     * // Get one Domain
     * const domain = await prisma.domain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Domains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Domains
     * const domains = await prisma.domain.findMany()
     * 
     * // Get first 10 Domains
     * const domains = await prisma.domain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainWithIdOnly = await prisma.domain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainFindManyArgs>(args?: SelectSubset<T, DomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Domain.
     * @param {DomainCreateArgs} args - Arguments to create a Domain.
     * @example
     * // Create one Domain
     * const Domain = await prisma.domain.create({
     *   data: {
     *     // ... data to create a Domain
     *   }
     * })
     * 
     */
    create<T extends DomainCreateArgs>(args: SelectSubset<T, DomainCreateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Domains.
     * @param {DomainCreateManyArgs} args - Arguments to create many Domains.
     * @example
     * // Create many Domains
     * const domain = await prisma.domain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainCreateManyArgs>(args?: SelectSubset<T, DomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Domain.
     * @param {DomainDeleteArgs} args - Arguments to delete one Domain.
     * @example
     * // Delete one Domain
     * const Domain = await prisma.domain.delete({
     *   where: {
     *     // ... filter to delete one Domain
     *   }
     * })
     * 
     */
    delete<T extends DomainDeleteArgs>(args: SelectSubset<T, DomainDeleteArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Domain.
     * @param {DomainUpdateArgs} args - Arguments to update one Domain.
     * @example
     * // Update one Domain
     * const domain = await prisma.domain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainUpdateArgs>(args: SelectSubset<T, DomainUpdateArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Domains.
     * @param {DomainDeleteManyArgs} args - Arguments to filter Domains to delete.
     * @example
     * // Delete a few Domains
     * const { count } = await prisma.domain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainDeleteManyArgs>(args?: SelectSubset<T, DomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Domains
     * const domain = await prisma.domain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainUpdateManyArgs>(args: SelectSubset<T, DomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Domain.
     * @param {DomainUpsertArgs} args - Arguments to update or create a Domain.
     * @example
     * // Update or create a Domain
     * const domain = await prisma.domain.upsert({
     *   create: {
     *     // ... data to create a Domain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Domain we want to update
     *   }
     * })
     */
    upsert<T extends DomainUpsertArgs>(args: SelectSubset<T, DomainUpsertArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Domains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCountArgs} args - Arguments to filter Domains to count.
     * @example
     * // Count the number of Domains
     * const count = await prisma.domain.count({
     *   where: {
     *     // ... the filter for the Domains we want to count
     *   }
     * })
    **/
    count<T extends DomainCountArgs>(
      args?: Subset<T, DomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAggregateArgs>(args: Subset<T, DomainAggregateArgs>): Prisma.PrismaPromise<GetDomainAggregateType<T>>

    /**
     * Group by Domain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainGroupByArgs['orderBy'] }
        : { orderBy?: DomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Domain model
   */
  readonly fields: DomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Domain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    emailAccounts<T extends Domain$emailAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Domain$emailAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Domain model
   */ 
  interface DomainFieldRefs {
    readonly id: FieldRef<"Domain", 'Int'>
    readonly domainName: FieldRef<"Domain", 'String'>
    readonly userId: FieldRef<"Domain", 'Int'>
    readonly dnsVerified: FieldRef<"Domain", 'Boolean'>
    readonly mxRecord: FieldRef<"Domain", 'String'>
    readonly spfRecord: FieldRef<"Domain", 'String'>
    readonly dkimRecord: FieldRef<"Domain", 'String'>
    readonly dmarcRecord: FieldRef<"Domain", 'String'>
    readonly lastDnsCheck: FieldRef<"Domain", 'DateTime'>
    readonly smtpProvider: FieldRef<"Domain", 'String'>
    readonly smtpHost: FieldRef<"Domain", 'String'>
    readonly smtpPort: FieldRef<"Domain", 'Int'>
    readonly smtpUser: FieldRef<"Domain", 'String'>
    readonly smtpPassword: FieldRef<"Domain", 'String'>
    readonly smtpApiKey: FieldRef<"Domain", 'String'>
    readonly createdAt: FieldRef<"Domain", 'DateTime'>
    readonly updatedAt: FieldRef<"Domain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Domain findUnique
   */
  export type DomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findUniqueOrThrow
   */
  export type DomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain findFirst
   */
  export type DomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findFirstOrThrow
   */
  export type DomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domain to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Domains.
     */
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain findMany
   */
  export type DomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter, which Domains to fetch.
     */
    where?: DomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Domains to fetch.
     */
    orderBy?: DomainOrderByWithRelationInput | DomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Domains.
     */
    cursor?: DomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Domains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Domains.
     */
    skip?: number
    distinct?: DomainScalarFieldEnum | DomainScalarFieldEnum[]
  }

  /**
   * Domain create
   */
  export type DomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The data needed to create a Domain.
     */
    data: XOR<DomainCreateInput, DomainUncheckedCreateInput>
  }

  /**
   * Domain createMany
   */
  export type DomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Domains.
     */
    data: DomainCreateManyInput | DomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Domain update
   */
  export type DomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The data needed to update a Domain.
     */
    data: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
    /**
     * Choose, which Domain to update.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain updateMany
   */
  export type DomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Domains.
     */
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyInput>
    /**
     * Filter which Domains to update
     */
    where?: DomainWhereInput
  }

  /**
   * Domain upsert
   */
  export type DomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * The filter to search for the Domain to update in case it exists.
     */
    where: DomainWhereUniqueInput
    /**
     * In case the Domain found by the `where` argument doesn't exist, create a new Domain with this data.
     */
    create: XOR<DomainCreateInput, DomainUncheckedCreateInput>
    /**
     * In case the Domain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainUpdateInput, DomainUncheckedUpdateInput>
  }

  /**
   * Domain delete
   */
  export type DomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
    /**
     * Filter which Domain to delete.
     */
    where: DomainWhereUniqueInput
  }

  /**
   * Domain deleteMany
   */
  export type DomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Domains to delete
     */
    where?: DomainWhereInput
  }

  /**
   * Domain.emailAccounts
   */
  export type Domain$emailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    cursor?: EmailAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * Domain without action
   */
  export type DomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Domain
     */
    select?: DomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainInclude<ExtArgs> | null
  }


  /**
   * Model EmailAccount
   */

  export type AggregateEmailAccount = {
    _count: EmailAccountCountAggregateOutputType | null
    _avg: EmailAccountAvgAggregateOutputType | null
    _sum: EmailAccountSumAggregateOutputType | null
    _min: EmailAccountMinAggregateOutputType | null
    _max: EmailAccountMaxAggregateOutputType | null
  }

  export type EmailAccountAvgAggregateOutputType = {
    id: number | null
    storageUsed: number | null
    domainId: number | null
    ownerId: number | null
    smtpPort: number | null
  }

  export type EmailAccountSumAggregateOutputType = {
    id: number | null
    storageUsed: number | null
    domainId: number | null
    ownerId: number | null
    smtpPort: number | null
  }

  export type EmailAccountMinAggregateOutputType = {
    id: number | null
    address: string | null
    password: string | null
    storageUsed: number | null
    domainId: number | null
    ownerId: number | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    createdAt: Date | null
  }

  export type EmailAccountMaxAggregateOutputType = {
    id: number | null
    address: string | null
    password: string | null
    storageUsed: number | null
    domainId: number | null
    ownerId: number | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    createdAt: Date | null
  }

  export type EmailAccountCountAggregateOutputType = {
    id: number
    address: number
    password: number
    storageUsed: number
    domainId: number
    ownerId: number
    smtpHost: number
    smtpPort: number
    smtpUser: number
    smtpPassword: number
    createdAt: number
    _all: number
  }


  export type EmailAccountAvgAggregateInputType = {
    id?: true
    storageUsed?: true
    domainId?: true
    ownerId?: true
    smtpPort?: true
  }

  export type EmailAccountSumAggregateInputType = {
    id?: true
    storageUsed?: true
    domainId?: true
    ownerId?: true
    smtpPort?: true
  }

  export type EmailAccountMinAggregateInputType = {
    id?: true
    address?: true
    password?: true
    storageUsed?: true
    domainId?: true
    ownerId?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    createdAt?: true
  }

  export type EmailAccountMaxAggregateInputType = {
    id?: true
    address?: true
    password?: true
    storageUsed?: true
    domainId?: true
    ownerId?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    createdAt?: true
  }

  export type EmailAccountCountAggregateInputType = {
    id?: true
    address?: true
    password?: true
    storageUsed?: true
    domainId?: true
    ownerId?: true
    smtpHost?: true
    smtpPort?: true
    smtpUser?: true
    smtpPassword?: true
    createdAt?: true
    _all?: true
  }

  export type EmailAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAccount to aggregate.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAccounts
    **/
    _count?: true | EmailAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAccountMaxAggregateInputType
  }

  export type GetEmailAccountAggregateType<T extends EmailAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAccount[P]>
      : GetScalarType<T[P], AggregateEmailAccount[P]>
  }




  export type EmailAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithAggregationInput | EmailAccountOrderByWithAggregationInput[]
    by: EmailAccountScalarFieldEnum[] | EmailAccountScalarFieldEnum
    having?: EmailAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAccountCountAggregateInputType | true
    _avg?: EmailAccountAvgAggregateInputType
    _sum?: EmailAccountSumAggregateInputType
    _min?: EmailAccountMinAggregateInputType
    _max?: EmailAccountMaxAggregateInputType
  }

  export type EmailAccountGroupByOutputType = {
    id: number
    address: string
    password: string
    storageUsed: number
    domainId: number
    ownerId: number | null
    smtpHost: string | null
    smtpPort: number | null
    smtpUser: string | null
    smtpPassword: string | null
    createdAt: Date
    _count: EmailAccountCountAggregateOutputType | null
    _avg: EmailAccountAvgAggregateOutputType | null
    _sum: EmailAccountSumAggregateOutputType | null
    _min: EmailAccountMinAggregateOutputType | null
    _max: EmailAccountMaxAggregateOutputType | null
  }

  type GetEmailAccountGroupByPayload<T extends EmailAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAccountGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAccountGroupByOutputType[P]>
        }
      >
    >


  export type EmailAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    password?: boolean
    storageUsed?: boolean
    domainId?: boolean
    ownerId?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    createdAt?: boolean
    domain?: boolean | DomainDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
    emails?: boolean | EmailAccount$emailsArgs<ExtArgs>
    _count?: boolean | EmailAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAccount"]>


  export type EmailAccountSelectScalar = {
    id?: boolean
    address?: boolean
    password?: boolean
    storageUsed?: boolean
    domainId?: boolean
    ownerId?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    createdAt?: boolean
  }

  export type EmailAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | DomainDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
    emails?: boolean | EmailAccount$emailsArgs<ExtArgs>
    _count?: boolean | EmailAccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmailAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAccount"
    objects: {
      domain: Prisma.$DomainPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
      emails: Prisma.$EmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      address: string
      password: string
      storageUsed: number
      domainId: number
      ownerId: number | null
      smtpHost: string | null
      smtpPort: number | null
      smtpUser: string | null
      smtpPassword: string | null
      createdAt: Date
    }, ExtArgs["result"]["emailAccount"]>
    composites: {}
  }

  type EmailAccountGetPayload<S extends boolean | null | undefined | EmailAccountDefaultArgs> = $Result.GetResult<Prisma.$EmailAccountPayload, S>

  type EmailAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailAccountCountAggregateInputType | true
    }

  export interface EmailAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAccount'], meta: { name: 'EmailAccount' } }
    /**
     * Find zero or one EmailAccount that matches the filter.
     * @param {EmailAccountFindUniqueArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAccountFindUniqueArgs>(args: SelectSubset<T, EmailAccountFindUniqueArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailAccountFindUniqueOrThrowArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindFirstArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAccountFindFirstArgs>(args?: SelectSubset<T, EmailAccountFindFirstArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindFirstOrThrowArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAccounts
     * const emailAccounts = await prisma.emailAccount.findMany()
     * 
     * // Get first 10 EmailAccounts
     * const emailAccounts = await prisma.emailAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAccountWithIdOnly = await prisma.emailAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAccountFindManyArgs>(args?: SelectSubset<T, EmailAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailAccount.
     * @param {EmailAccountCreateArgs} args - Arguments to create a EmailAccount.
     * @example
     * // Create one EmailAccount
     * const EmailAccount = await prisma.emailAccount.create({
     *   data: {
     *     // ... data to create a EmailAccount
     *   }
     * })
     * 
     */
    create<T extends EmailAccountCreateArgs>(args: SelectSubset<T, EmailAccountCreateArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailAccounts.
     * @param {EmailAccountCreateManyArgs} args - Arguments to create many EmailAccounts.
     * @example
     * // Create many EmailAccounts
     * const emailAccount = await prisma.emailAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAccountCreateManyArgs>(args?: SelectSubset<T, EmailAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailAccount.
     * @param {EmailAccountDeleteArgs} args - Arguments to delete one EmailAccount.
     * @example
     * // Delete one EmailAccount
     * const EmailAccount = await prisma.emailAccount.delete({
     *   where: {
     *     // ... filter to delete one EmailAccount
     *   }
     * })
     * 
     */
    delete<T extends EmailAccountDeleteArgs>(args: SelectSubset<T, EmailAccountDeleteArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailAccount.
     * @param {EmailAccountUpdateArgs} args - Arguments to update one EmailAccount.
     * @example
     * // Update one EmailAccount
     * const emailAccount = await prisma.emailAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAccountUpdateArgs>(args: SelectSubset<T, EmailAccountUpdateArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailAccounts.
     * @param {EmailAccountDeleteManyArgs} args - Arguments to filter EmailAccounts to delete.
     * @example
     * // Delete a few EmailAccounts
     * const { count } = await prisma.emailAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAccountDeleteManyArgs>(args?: SelectSubset<T, EmailAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAccounts
     * const emailAccount = await prisma.emailAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAccountUpdateManyArgs>(args: SelectSubset<T, EmailAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailAccount.
     * @param {EmailAccountUpsertArgs} args - Arguments to update or create a EmailAccount.
     * @example
     * // Update or create a EmailAccount
     * const emailAccount = await prisma.emailAccount.upsert({
     *   create: {
     *     // ... data to create a EmailAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAccount we want to update
     *   }
     * })
     */
    upsert<T extends EmailAccountUpsertArgs>(args: SelectSubset<T, EmailAccountUpsertArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountCountArgs} args - Arguments to filter EmailAccounts to count.
     * @example
     * // Count the number of EmailAccounts
     * const count = await prisma.emailAccount.count({
     *   where: {
     *     // ... the filter for the EmailAccounts we want to count
     *   }
     * })
    **/
    count<T extends EmailAccountCountArgs>(
      args?: Subset<T, EmailAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAccountAggregateArgs>(args: Subset<T, EmailAccountAggregateArgs>): Prisma.PrismaPromise<GetEmailAccountAggregateType<T>>

    /**
     * Group by EmailAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAccountGroupByArgs['orderBy'] }
        : { orderBy?: EmailAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAccount model
   */
  readonly fields: EmailAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends DomainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainDefaultArgs<ExtArgs>>): Prisma__DomainClient<$Result.GetResult<Prisma.$DomainPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends EmailAccount$ownerArgs<ExtArgs> = {}>(args?: Subset<T, EmailAccount$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    emails<T extends EmailAccount$emailsArgs<ExtArgs> = {}>(args?: Subset<T, EmailAccount$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAccount model
   */ 
  interface EmailAccountFieldRefs {
    readonly id: FieldRef<"EmailAccount", 'Int'>
    readonly address: FieldRef<"EmailAccount", 'String'>
    readonly password: FieldRef<"EmailAccount", 'String'>
    readonly storageUsed: FieldRef<"EmailAccount", 'Float'>
    readonly domainId: FieldRef<"EmailAccount", 'Int'>
    readonly ownerId: FieldRef<"EmailAccount", 'Int'>
    readonly smtpHost: FieldRef<"EmailAccount", 'String'>
    readonly smtpPort: FieldRef<"EmailAccount", 'Int'>
    readonly smtpUser: FieldRef<"EmailAccount", 'String'>
    readonly smtpPassword: FieldRef<"EmailAccount", 'String'>
    readonly createdAt: FieldRef<"EmailAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAccount findUnique
   */
  export type EmailAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount findUniqueOrThrow
   */
  export type EmailAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount findFirst
   */
  export type EmailAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAccounts.
     */
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount findFirstOrThrow
   */
  export type EmailAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAccounts.
     */
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount findMany
   */
  export type EmailAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccounts to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount create
   */
  export type EmailAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAccount.
     */
    data: XOR<EmailAccountCreateInput, EmailAccountUncheckedCreateInput>
  }

  /**
   * EmailAccount createMany
   */
  export type EmailAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAccounts.
     */
    data: EmailAccountCreateManyInput | EmailAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAccount update
   */
  export type EmailAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAccount.
     */
    data: XOR<EmailAccountUpdateInput, EmailAccountUncheckedUpdateInput>
    /**
     * Choose, which EmailAccount to update.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount updateMany
   */
  export type EmailAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAccounts.
     */
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyInput>
    /**
     * Filter which EmailAccounts to update
     */
    where?: EmailAccountWhereInput
  }

  /**
   * EmailAccount upsert
   */
  export type EmailAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAccount to update in case it exists.
     */
    where: EmailAccountWhereUniqueInput
    /**
     * In case the EmailAccount found by the `where` argument doesn't exist, create a new EmailAccount with this data.
     */
    create: XOR<EmailAccountCreateInput, EmailAccountUncheckedCreateInput>
    /**
     * In case the EmailAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAccountUpdateInput, EmailAccountUncheckedUpdateInput>
  }

  /**
   * EmailAccount delete
   */
  export type EmailAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter which EmailAccount to delete.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount deleteMany
   */
  export type EmailAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAccounts to delete
     */
    where?: EmailAccountWhereInput
  }

  /**
   * EmailAccount.owner
   */
  export type EmailAccount$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EmailAccount.emails
   */
  export type EmailAccount$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * EmailAccount without action
   */
  export type EmailAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
  }


  /**
   * Model Email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailAvgAggregateOutputType = {
    id: number | null
    emailAccountId: number | null
    folderId: number | null
  }

  export type EmailSumAggregateOutputType = {
    id: number | null
    emailAccountId: number | null
    folderId: number | null
  }

  export type EmailMinAggregateOutputType = {
    id: number | null
    emailAccountId: number | null
    from: string | null
    to: string | null
    subject: string | null
    body: string | null
    htmlBody: string | null
    isRead: boolean | null
    isSent: boolean | null
    messageId: string | null
    inReplyTo: string | null
    references: string | null
    priority: string | null
    receivedAt: Date | null
    sentAt: Date | null
    isStarred: boolean | null
    isArchived: boolean | null
    isSpam: boolean | null
    isImportant: boolean | null
    isDraft: boolean | null
    isDeleted: boolean | null
    folderId: number | null
    labels: string | null
    scheduledFor: Date | null
  }

  export type EmailMaxAggregateOutputType = {
    id: number | null
    emailAccountId: number | null
    from: string | null
    to: string | null
    subject: string | null
    body: string | null
    htmlBody: string | null
    isRead: boolean | null
    isSent: boolean | null
    messageId: string | null
    inReplyTo: string | null
    references: string | null
    priority: string | null
    receivedAt: Date | null
    sentAt: Date | null
    isStarred: boolean | null
    isArchived: boolean | null
    isSpam: boolean | null
    isImportant: boolean | null
    isDraft: boolean | null
    isDeleted: boolean | null
    folderId: number | null
    labels: string | null
    scheduledFor: Date | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    emailAccountId: number
    from: number
    to: number
    subject: number
    body: number
    htmlBody: number
    isRead: number
    isSent: number
    messageId: number
    inReplyTo: number
    references: number
    priority: number
    receivedAt: number
    sentAt: number
    isStarred: number
    isArchived: number
    isSpam: number
    isImportant: number
    isDraft: number
    isDeleted: number
    folderId: number
    labels: number
    scheduledFor: number
    _all: number
  }


  export type EmailAvgAggregateInputType = {
    id?: true
    emailAccountId?: true
    folderId?: true
  }

  export type EmailSumAggregateInputType = {
    id?: true
    emailAccountId?: true
    folderId?: true
  }

  export type EmailMinAggregateInputType = {
    id?: true
    emailAccountId?: true
    from?: true
    to?: true
    subject?: true
    body?: true
    htmlBody?: true
    isRead?: true
    isSent?: true
    messageId?: true
    inReplyTo?: true
    references?: true
    priority?: true
    receivedAt?: true
    sentAt?: true
    isStarred?: true
    isArchived?: true
    isSpam?: true
    isImportant?: true
    isDraft?: true
    isDeleted?: true
    folderId?: true
    labels?: true
    scheduledFor?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    emailAccountId?: true
    from?: true
    to?: true
    subject?: true
    body?: true
    htmlBody?: true
    isRead?: true
    isSent?: true
    messageId?: true
    inReplyTo?: true
    references?: true
    priority?: true
    receivedAt?: true
    sentAt?: true
    isStarred?: true
    isArchived?: true
    isSpam?: true
    isImportant?: true
    isDraft?: true
    isDeleted?: true
    folderId?: true
    labels?: true
    scheduledFor?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    emailAccountId?: true
    from?: true
    to?: true
    subject?: true
    body?: true
    htmlBody?: true
    isRead?: true
    isSent?: true
    messageId?: true
    inReplyTo?: true
    references?: true
    priority?: true
    receivedAt?: true
    sentAt?: true
    isStarred?: true
    isArchived?: true
    isSpam?: true
    isImportant?: true
    isDraft?: true
    isDeleted?: true
    folderId?: true
    labels?: true
    scheduledFor?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Email to aggregate.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type EmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithAggregationInput | EmailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: EmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _avg?: EmailAvgAggregateInputType
    _sum?: EmailSumAggregateInputType
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    id: number
    emailAccountId: number
    from: string
    to: string
    subject: string
    body: string
    htmlBody: string | null
    isRead: boolean
    isSent: boolean
    messageId: string | null
    inReplyTo: string | null
    references: string | null
    priority: string | null
    receivedAt: Date
    sentAt: Date | null
    isStarred: boolean
    isArchived: boolean
    isSpam: boolean
    isImportant: boolean
    isDraft: boolean
    isDeleted: boolean
    folderId: number | null
    labels: string | null
    scheduledFor: Date | null
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends EmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type EmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailAccountId?: boolean
    from?: boolean
    to?: boolean
    subject?: boolean
    body?: boolean
    htmlBody?: boolean
    isRead?: boolean
    isSent?: boolean
    messageId?: boolean
    inReplyTo?: boolean
    references?: boolean
    priority?: boolean
    receivedAt?: boolean
    sentAt?: boolean
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: boolean
    labels?: boolean
    scheduledFor?: boolean
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
    attachments?: boolean | Email$attachmentsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>


  export type EmailSelectScalar = {
    id?: boolean
    emailAccountId?: boolean
    from?: boolean
    to?: boolean
    subject?: boolean
    body?: boolean
    htmlBody?: boolean
    isRead?: boolean
    isSent?: boolean
    messageId?: boolean
    inReplyTo?: boolean
    references?: boolean
    priority?: boolean
    receivedAt?: boolean
    sentAt?: boolean
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: boolean
    labels?: boolean
    scheduledFor?: boolean
  }

  export type EmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
    attachments?: boolean | Email$attachmentsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Email"
    objects: {
      account: Prisma.$EmailAccountPayload<ExtArgs>
      attachments: Prisma.$EmailAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      emailAccountId: number
      from: string
      to: string
      subject: string
      body: string
      htmlBody: string | null
      isRead: boolean
      isSent: boolean
      messageId: string | null
      inReplyTo: string | null
      references: string | null
      priority: string | null
      receivedAt: Date
      sentAt: Date | null
      isStarred: boolean
      isArchived: boolean
      isSpam: boolean
      isImportant: boolean
      isDraft: boolean
      isDeleted: boolean
      folderId: number | null
      labels: string | null
      scheduledFor: Date | null
    }, ExtArgs["result"]["email"]>
    composites: {}
  }

  type EmailGetPayload<S extends boolean | null | undefined | EmailDefaultArgs> = $Result.GetResult<Prisma.$EmailPayload, S>

  type EmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailCountAggregateInputType | true
    }

  export interface EmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Email'], meta: { name: 'Email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {EmailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailFindUniqueArgs>(args: SelectSubset<T, EmailFindUniqueArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Email that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailFindFirstArgs>(args?: SelectSubset<T, EmailFindFirstArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailFindManyArgs>(args?: SelectSubset<T, EmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Email.
     * @param {EmailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
     */
    create<T extends EmailCreateArgs>(args: SelectSubset<T, EmailCreateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Emails.
     * @param {EmailCreateManyArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCreateManyArgs>(args?: SelectSubset<T, EmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Email.
     * @param {EmailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
     */
    delete<T extends EmailDeleteArgs>(args: SelectSubset<T, EmailDeleteArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Email.
     * @param {EmailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailUpdateArgs>(args: SelectSubset<T, EmailUpdateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Emails.
     * @param {EmailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailDeleteManyArgs>(args?: SelectSubset<T, EmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailUpdateManyArgs>(args: SelectSubset<T, EmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Email.
     * @param {EmailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
     */
    upsert<T extends EmailUpsertArgs>(args: SelectSubset<T, EmailUpsertArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends EmailCountArgs>(
      args?: Subset<T, EmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGroupByArgs['orderBy'] }
        : { orderBy?: EmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Email model
   */
  readonly fields: EmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends EmailAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailAccountDefaultArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends Email$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Email$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Email model
   */ 
  interface EmailFieldRefs {
    readonly id: FieldRef<"Email", 'Int'>
    readonly emailAccountId: FieldRef<"Email", 'Int'>
    readonly from: FieldRef<"Email", 'String'>
    readonly to: FieldRef<"Email", 'String'>
    readonly subject: FieldRef<"Email", 'String'>
    readonly body: FieldRef<"Email", 'String'>
    readonly htmlBody: FieldRef<"Email", 'String'>
    readonly isRead: FieldRef<"Email", 'Boolean'>
    readonly isSent: FieldRef<"Email", 'Boolean'>
    readonly messageId: FieldRef<"Email", 'String'>
    readonly inReplyTo: FieldRef<"Email", 'String'>
    readonly references: FieldRef<"Email", 'String'>
    readonly priority: FieldRef<"Email", 'String'>
    readonly receivedAt: FieldRef<"Email", 'DateTime'>
    readonly sentAt: FieldRef<"Email", 'DateTime'>
    readonly isStarred: FieldRef<"Email", 'Boolean'>
    readonly isArchived: FieldRef<"Email", 'Boolean'>
    readonly isSpam: FieldRef<"Email", 'Boolean'>
    readonly isImportant: FieldRef<"Email", 'Boolean'>
    readonly isDraft: FieldRef<"Email", 'Boolean'>
    readonly isDeleted: FieldRef<"Email", 'Boolean'>
    readonly folderId: FieldRef<"Email", 'Int'>
    readonly labels: FieldRef<"Email", 'String'>
    readonly scheduledFor: FieldRef<"Email", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Email findUnique
   */
  export type EmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findUniqueOrThrow
   */
  export type EmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findFirst
   */
  export type EmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findFirstOrThrow
   */
  export type EmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findMany
   */
  export type EmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Emails to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email create
   */
  export type EmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to create a Email.
     */
    data: XOR<EmailCreateInput, EmailUncheckedCreateInput>
  }

  /**
   * Email createMany
   */
  export type EmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Email update
   */
  export type EmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to update a Email.
     */
    data: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    /**
     * Choose, which Email to update.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email updateMany
   */
  export type EmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
  }

  /**
   * Email upsert
   */
  export type EmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The filter to search for the Email to update in case it exists.
     */
    where: EmailWhereUniqueInput
    /**
     * In case the Email found by the `where` argument doesn't exist, create a new Email with this data.
     */
    create: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    /**
     * In case the Email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
  }

  /**
   * Email delete
   */
  export type EmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter which Email to delete.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email deleteMany
   */
  export type EmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emails to delete
     */
    where?: EmailWhereInput
  }

  /**
   * Email.attachments
   */
  export type Email$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    where?: EmailAttachmentWhereInput
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    cursor?: EmailAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * Email without action
   */
  export type EmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    id: number | null
    priceMonthly: number | null
    priceYearly: number | null
    maxEmails: number | null
    maxStorageGB: number | null
    maxDomains: number | null
  }

  export type PlanSumAggregateOutputType = {
    id: number | null
    priceMonthly: number | null
    priceYearly: number | null
    maxEmails: number | null
    maxStorageGB: number | null
    maxDomains: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    priceMonthly: number | null
    priceYearly: number | null
    maxEmails: number | null
    maxStorageGB: number | null
    maxDomains: number | null
    features: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    priceMonthly: number | null
    priceYearly: number | null
    maxEmails: number | null
    maxStorageGB: number | null
    maxDomains: number | null
    features: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    priceMonthly: number
    priceYearly: number
    maxEmails: number
    maxStorageGB: number
    maxDomains: number
    features: number
    category: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    id?: true
    priceMonthly?: true
    priceYearly?: true
    maxEmails?: true
    maxStorageGB?: true
    maxDomains?: true
  }

  export type PlanSumAggregateInputType = {
    id?: true
    priceMonthly?: true
    priceYearly?: true
    maxEmails?: true
    maxStorageGB?: true
    maxDomains?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    maxEmails?: true
    maxStorageGB?: true
    maxDomains?: true
    features?: true
    category?: true
    isActive?: true
    createdAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    maxEmails?: true
    maxStorageGB?: true
    maxDomains?: true
    features?: true
    category?: true
    isActive?: true
    createdAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    maxEmails?: true
    maxStorageGB?: true
    maxDomains?: true
    features?: true
    category?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: number
    name: string
    description: string | null
    priceMonthly: number
    priceYearly: number
    maxEmails: number
    maxStorageGB: number
    maxDomains: number
    features: string | null
    category: string
    isActive: boolean
    createdAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    maxEmails?: boolean
    maxStorageGB?: boolean
    maxDomains?: boolean
    features?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>


  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    maxEmails?: boolean
    maxStorageGB?: boolean
    maxDomains?: boolean
    features?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      priceMonthly: number
      priceYearly: number
      maxEmails: number
      maxStorageGB: number
      maxDomains: number
      features: string | null
      category: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'Int'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly priceMonthly: FieldRef<"Plan", 'Float'>
    readonly priceYearly: FieldRef<"Plan", 'Float'>
    readonly maxEmails: FieldRef<"Plan", 'Int'>
    readonly maxStorageGB: FieldRef<"Plan", 'Int'>
    readonly maxDomains: FieldRef<"Plan", 'Int'>
    readonly features: FieldRef<"Plan", 'String'>
    readonly category: FieldRef<"Plan", 'String'>
    readonly isActive: FieldRef<"Plan", 'Boolean'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    planId: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    planId: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    plan: string | null
    startDate: Date | null
    endDate: Date | null
    planId: number | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    plan: string | null
    startDate: Date | null
    endDate: Date | null
    planId: number | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    plan: number
    startDate: number
    endDate: number
    planId: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    startDate?: true
    endDate?: true
    planId?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    startDate?: true
    endDate?: true
    planId?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    startDate?: true
    endDate?: true
    planId?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    userId: number
    plan: string
    startDate: Date
    endDate: Date | null
    planId: number | null
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    planId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    Plan?: boolean | Subscription$PlanArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>


  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    planId?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    Plan?: boolean | Subscription$PlanArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      Plan: Prisma.$PlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      plan: string
      startDate: Date
      endDate: Date | null
      planId: number | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    Plan<T extends Subscription$PlanArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$PlanArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly userId: FieldRef<"Subscription", 'Int'>
    readonly plan: FieldRef<"Subscription", 'String'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly planId: FieldRef<"Subscription", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Subscription.Plan
   */
  export type Subscription$PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    subscriptionId: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    subscriptionId: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    subscriptionId: number | null
    createdAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    subscriptionId: number | null
    createdAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    userId: number
    subscriptionId: number
    createdAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    createdAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    createdAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    userId: number
    subscriptionId: number | null
    createdAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>


  export type InvoiceSelectScalar = {
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    createdAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | Invoice$subscriptionArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      subscriptionId: number | null
      createdAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subscription<T extends Invoice$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly userId: FieldRef<"Invoice", 'Int'>
    readonly subscriptionId: FieldRef<"Invoice", 'Int'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.subscription
   */
  export type Invoice$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TicketSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: number | null
    userId: number | null
    subject: string | null
    description: string | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    subject: string | null
    description: string | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    userId: number
    subject: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TicketSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: number
    userId: number
    subject: string
    description: string
    status: string
    priority: string
    createdAt: Date
    updatedAt: Date
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>


  export type TicketSelectScalar = {
    id?: boolean
    userId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      messages: Prisma.$TicketMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      subject: string
      description: string
      status: string
      priority: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends Ticket$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Ticket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'Int'>
    readonly userId: FieldRef<"Ticket", 'Int'>
    readonly subject: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'String'>
    readonly priority: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket.attachments
   */
  export type Ticket$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * Ticket.messages
   */
  export type Ticket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    cursor?: TicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketAttachment
   */

  export type AggregateTicketAttachment = {
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  export type TicketAttachmentAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    fileSize: number | null
  }

  export type TicketAttachmentSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    fileSize: number | null
  }

  export type TicketAttachmentMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type TicketAttachmentMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type TicketAttachmentCountAggregateOutputType = {
    id: number
    ticketId: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    createdAt: number
    _all: number
  }


  export type TicketAttachmentAvgAggregateInputType = {
    id?: true
    ticketId?: true
    fileSize?: true
  }

  export type TicketAttachmentSumAggregateInputType = {
    id?: true
    ticketId?: true
    fileSize?: true
  }

  export type TicketAttachmentMinAggregateInputType = {
    id?: true
    ticketId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
  }

  export type TicketAttachmentMaxAggregateInputType = {
    id?: true
    ticketId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
  }

  export type TicketAttachmentCountAggregateInputType = {
    id?: true
    ticketId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    _all?: true
  }

  export type TicketAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachment to aggregate.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketAttachments
    **/
    _count?: true | TicketAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type GetTicketAttachmentAggregateType<T extends TicketAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketAttachment[P]>
      : GetScalarType<T[P], AggregateTicketAttachment[P]>
  }




  export type TicketAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithAggregationInput | TicketAttachmentOrderByWithAggregationInput[]
    by: TicketAttachmentScalarFieldEnum[] | TicketAttachmentScalarFieldEnum
    having?: TicketAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketAttachmentCountAggregateInputType | true
    _avg?: TicketAttachmentAvgAggregateInputType
    _sum?: TicketAttachmentSumAggregateInputType
    _min?: TicketAttachmentMinAggregateInputType
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type TicketAttachmentGroupByOutputType = {
    id: number
    ticketId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt: Date
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  type GetTicketAttachmentGroupByPayload<T extends TicketAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TicketAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>


  export type TicketAttachmentSelectScalar = {
    id?: boolean
    ticketId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
  }

  export type TicketAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketAttachment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      createdAt: Date
    }, ExtArgs["result"]["ticketAttachment"]>
    composites: {}
  }

  type TicketAttachmentGetPayload<S extends boolean | null | undefined | TicketAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TicketAttachmentPayload, S>

  type TicketAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketAttachmentCountAggregateInputType | true
    }

  export interface TicketAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketAttachment'], meta: { name: 'TicketAttachment' } }
    /**
     * Find zero or one TicketAttachment that matches the filter.
     * @param {TicketAttachmentFindUniqueArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketAttachmentFindUniqueArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketAttachmentFindFirstArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany()
     * 
     * // Get first 10 TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketAttachmentFindManyArgs>(args?: SelectSubset<T, TicketAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketAttachment.
     * @param {TicketAttachmentCreateArgs} args - Arguments to create a TicketAttachment.
     * @example
     * // Create one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.create({
     *   data: {
     *     // ... data to create a TicketAttachment
     *   }
     * })
     * 
     */
    create<T extends TicketAttachmentCreateArgs>(args: SelectSubset<T, TicketAttachmentCreateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketAttachments.
     * @param {TicketAttachmentCreateManyArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketAttachmentCreateManyArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketAttachment.
     * @param {TicketAttachmentDeleteArgs} args - Arguments to delete one TicketAttachment.
     * @example
     * // Delete one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.delete({
     *   where: {
     *     // ... filter to delete one TicketAttachment
     *   }
     * })
     * 
     */
    delete<T extends TicketAttachmentDeleteArgs>(args: SelectSubset<T, TicketAttachmentDeleteArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketAttachment.
     * @param {TicketAttachmentUpdateArgs} args - Arguments to update one TicketAttachment.
     * @example
     * // Update one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketAttachmentUpdateArgs>(args: SelectSubset<T, TicketAttachmentUpdateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketAttachments.
     * @param {TicketAttachmentDeleteManyArgs} args - Arguments to filter TicketAttachments to delete.
     * @example
     * // Delete a few TicketAttachments
     * const { count } = await prisma.ticketAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketAttachmentDeleteManyArgs>(args?: SelectSubset<T, TicketAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketAttachmentUpdateManyArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketAttachment.
     * @param {TicketAttachmentUpsertArgs} args - Arguments to update or create a TicketAttachment.
     * @example
     * // Update or create a TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.upsert({
     *   create: {
     *     // ... data to create a TicketAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TicketAttachmentUpsertArgs>(args: SelectSubset<T, TicketAttachmentUpsertArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentCountArgs} args - Arguments to filter TicketAttachments to count.
     * @example
     * // Count the number of TicketAttachments
     * const count = await prisma.ticketAttachment.count({
     *   where: {
     *     // ... the filter for the TicketAttachments we want to count
     *   }
     * })
    **/
    count<T extends TicketAttachmentCountArgs>(
      args?: Subset<T, TicketAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAttachmentAggregateArgs>(args: Subset<T, TicketAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTicketAttachmentAggregateType<T>>

    /**
     * Group by TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TicketAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketAttachment model
   */
  readonly fields: TicketAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketAttachment model
   */ 
  interface TicketAttachmentFieldRefs {
    readonly id: FieldRef<"TicketAttachment", 'Int'>
    readonly ticketId: FieldRef<"TicketAttachment", 'Int'>
    readonly fileName: FieldRef<"TicketAttachment", 'String'>
    readonly filePath: FieldRef<"TicketAttachment", 'String'>
    readonly fileSize: FieldRef<"TicketAttachment", 'Int'>
    readonly mimeType: FieldRef<"TicketAttachment", 'String'>
    readonly createdAt: FieldRef<"TicketAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketAttachment findUnique
   */
  export type TicketAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findUniqueOrThrow
   */
  export type TicketAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findFirst
   */
  export type TicketAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findFirstOrThrow
   */
  export type TicketAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findMany
   */
  export type TicketAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachments to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment create
   */
  export type TicketAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketAttachment.
     */
    data: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
  }

  /**
   * TicketAttachment createMany
   */
  export type TicketAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketAttachment update
   */
  export type TicketAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketAttachment.
     */
    data: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TicketAttachment to update.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment updateMany
   */
  export type TicketAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketAttachment upsert
   */
  export type TicketAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketAttachment to update in case it exists.
     */
    where: TicketAttachmentWhereUniqueInput
    /**
     * In case the TicketAttachment found by the `where` argument doesn't exist, create a new TicketAttachment with this data.
     */
    create: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
    /**
     * In case the TicketAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
  }

  /**
   * TicketAttachment delete
   */
  export type TicketAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TicketAttachment to delete.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment deleteMany
   */
  export type TicketAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachments to delete
     */
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketAttachment without action
   */
  export type TicketAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TicketMessage
   */

  export type AggregateTicketMessage = {
    _count: TicketMessageCountAggregateOutputType | null
    _avg: TicketMessageAvgAggregateOutputType | null
    _sum: TicketMessageSumAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  export type TicketMessageAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
  }

  export type TicketMessageSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
  }

  export type TicketMessageMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type TicketMessageMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    userId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type TicketMessageCountAggregateOutputType = {
    id: number
    ticketId: number
    userId: number
    message: number
    createdAt: number
    _all: number
  }


  export type TicketMessageAvgAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
  }

  export type TicketMessageSumAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
  }

  export type TicketMessageMinAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type TicketMessageMaxAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    createdAt?: true
  }

  export type TicketMessageCountAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type TicketMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessage to aggregate.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketMessages
    **/
    _count?: true | TicketMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMessageMaxAggregateInputType
  }

  export type GetTicketMessageAggregateType<T extends TicketMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketMessage[P]>
      : GetScalarType<T[P], AggregateTicketMessage[P]>
  }




  export type TicketMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithAggregationInput | TicketMessageOrderByWithAggregationInput[]
    by: TicketMessageScalarFieldEnum[] | TicketMessageScalarFieldEnum
    having?: TicketMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketMessageCountAggregateInputType | true
    _avg?: TicketMessageAvgAggregateInputType
    _sum?: TicketMessageSumAggregateInputType
    _min?: TicketMessageMinAggregateInputType
    _max?: TicketMessageMaxAggregateInputType
  }

  export type TicketMessageGroupByOutputType = {
    id: number
    ticketId: number
    userId: number
    message: string
    createdAt: Date
    _count: TicketMessageCountAggregateOutputType | null
    _avg: TicketMessageAvgAggregateOutputType | null
    _sum: TicketMessageSumAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  type GetTicketMessageGroupByPayload<T extends TicketMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
        }
      >
    >


  export type TicketMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>


  export type TicketMessageSelectScalar = {
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type TicketMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketMessage"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      userId: number
      message: string
      createdAt: Date
    }, ExtArgs["result"]["ticketMessage"]>
    composites: {}
  }

  type TicketMessageGetPayload<S extends boolean | null | undefined | TicketMessageDefaultArgs> = $Result.GetResult<Prisma.$TicketMessagePayload, S>

  type TicketMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketMessageCountAggregateInputType | true
    }

  export interface TicketMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketMessage'], meta: { name: 'TicketMessage' } }
    /**
     * Find zero or one TicketMessage that matches the filter.
     * @param {TicketMessageFindUniqueArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketMessageFindUniqueArgs>(args: SelectSubset<T, TicketMessageFindUniqueArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketMessageFindUniqueOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketMessageFindFirstArgs>(args?: SelectSubset<T, TicketMessageFindFirstArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany()
     * 
     * // Get first 10 TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketMessageFindManyArgs>(args?: SelectSubset<T, TicketMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketMessage.
     * @param {TicketMessageCreateArgs} args - Arguments to create a TicketMessage.
     * @example
     * // Create one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.create({
     *   data: {
     *     // ... data to create a TicketMessage
     *   }
     * })
     * 
     */
    create<T extends TicketMessageCreateArgs>(args: SelectSubset<T, TicketMessageCreateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketMessages.
     * @param {TicketMessageCreateManyArgs} args - Arguments to create many TicketMessages.
     * @example
     * // Create many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketMessageCreateManyArgs>(args?: SelectSubset<T, TicketMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketMessage.
     * @param {TicketMessageDeleteArgs} args - Arguments to delete one TicketMessage.
     * @example
     * // Delete one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.delete({
     *   where: {
     *     // ... filter to delete one TicketMessage
     *   }
     * })
     * 
     */
    delete<T extends TicketMessageDeleteArgs>(args: SelectSubset<T, TicketMessageDeleteArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketMessage.
     * @param {TicketMessageUpdateArgs} args - Arguments to update one TicketMessage.
     * @example
     * // Update one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketMessageUpdateArgs>(args: SelectSubset<T, TicketMessageUpdateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketMessages.
     * @param {TicketMessageDeleteManyArgs} args - Arguments to filter TicketMessages to delete.
     * @example
     * // Delete a few TicketMessages
     * const { count } = await prisma.ticketMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketMessageDeleteManyArgs>(args?: SelectSubset<T, TicketMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketMessageUpdateManyArgs>(args: SelectSubset<T, TicketMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketMessage.
     * @param {TicketMessageUpsertArgs} args - Arguments to update or create a TicketMessage.
     * @example
     * // Update or create a TicketMessage
     * const ticketMessage = await prisma.ticketMessage.upsert({
     *   create: {
     *     // ... data to create a TicketMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketMessage we want to update
     *   }
     * })
     */
    upsert<T extends TicketMessageUpsertArgs>(args: SelectSubset<T, TicketMessageUpsertArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageCountArgs} args - Arguments to filter TicketMessages to count.
     * @example
     * // Count the number of TicketMessages
     * const count = await prisma.ticketMessage.count({
     *   where: {
     *     // ... the filter for the TicketMessages we want to count
     *   }
     * })
    **/
    count<T extends TicketMessageCountArgs>(
      args?: Subset<T, TicketMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketMessageAggregateArgs>(args: Subset<T, TicketMessageAggregateArgs>): Prisma.PrismaPromise<GetTicketMessageAggregateType<T>>

    /**
     * Group by TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketMessageGroupByArgs['orderBy'] }
        : { orderBy?: TicketMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketMessage model
   */
  readonly fields: TicketMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketMessage model
   */ 
  interface TicketMessageFieldRefs {
    readonly id: FieldRef<"TicketMessage", 'Int'>
    readonly ticketId: FieldRef<"TicketMessage", 'Int'>
    readonly userId: FieldRef<"TicketMessage", 'Int'>
    readonly message: FieldRef<"TicketMessage", 'String'>
    readonly createdAt: FieldRef<"TicketMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketMessage findUnique
   */
  export type TicketMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findUniqueOrThrow
   */
  export type TicketMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findFirst
   */
  export type TicketMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findFirstOrThrow
   */
  export type TicketMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findMany
   */
  export type TicketMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessages to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage create
   */
  export type TicketMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketMessage.
     */
    data: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
  }

  /**
   * TicketMessage createMany
   */
  export type TicketMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketMessages.
     */
    data: TicketMessageCreateManyInput | TicketMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketMessage update
   */
  export type TicketMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketMessage.
     */
    data: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
    /**
     * Choose, which TicketMessage to update.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage updateMany
   */
  export type TicketMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketMessages.
     */
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyInput>
    /**
     * Filter which TicketMessages to update
     */
    where?: TicketMessageWhereInput
  }

  /**
   * TicketMessage upsert
   */
  export type TicketMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketMessage to update in case it exists.
     */
    where: TicketMessageWhereUniqueInput
    /**
     * In case the TicketMessage found by the `where` argument doesn't exist, create a new TicketMessage with this data.
     */
    create: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
    /**
     * In case the TicketMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
  }

  /**
   * TicketMessage delete
   */
  export type TicketMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter which TicketMessage to delete.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage deleteMany
   */
  export type TicketMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessages to delete
     */
    where?: TicketMessageWhereInput
  }

  /**
   * TicketMessage without action
   */
  export type TicketMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
  }


  /**
   * Model EmailAttachment
   */

  export type AggregateEmailAttachment = {
    _count: EmailAttachmentCountAggregateOutputType | null
    _avg: EmailAttachmentAvgAggregateOutputType | null
    _sum: EmailAttachmentSumAggregateOutputType | null
    _min: EmailAttachmentMinAggregateOutputType | null
    _max: EmailAttachmentMaxAggregateOutputType | null
  }

  export type EmailAttachmentAvgAggregateOutputType = {
    id: number | null
    emailId: number | null
    fileSize: number | null
  }

  export type EmailAttachmentSumAggregateOutputType = {
    id: number | null
    emailId: number | null
    fileSize: number | null
  }

  export type EmailAttachmentMinAggregateOutputType = {
    id: number | null
    emailId: number | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    contentId: string | null
    createdAt: Date | null
  }

  export type EmailAttachmentMaxAggregateOutputType = {
    id: number | null
    emailId: number | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    contentId: string | null
    createdAt: Date | null
  }

  export type EmailAttachmentCountAggregateOutputType = {
    id: number
    emailId: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    contentId: number
    createdAt: number
    _all: number
  }


  export type EmailAttachmentAvgAggregateInputType = {
    id?: true
    emailId?: true
    fileSize?: true
  }

  export type EmailAttachmentSumAggregateInputType = {
    id?: true
    emailId?: true
    fileSize?: true
  }

  export type EmailAttachmentMinAggregateInputType = {
    id?: true
    emailId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    contentId?: true
    createdAt?: true
  }

  export type EmailAttachmentMaxAggregateInputType = {
    id?: true
    emailId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    contentId?: true
    createdAt?: true
  }

  export type EmailAttachmentCountAggregateInputType = {
    id?: true
    emailId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    contentId?: true
    createdAt?: true
    _all?: true
  }

  export type EmailAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAttachment to aggregate.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAttachments
    **/
    _count?: true | EmailAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAttachmentMaxAggregateInputType
  }

  export type GetEmailAttachmentAggregateType<T extends EmailAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAttachment[P]>
      : GetScalarType<T[P], AggregateEmailAttachment[P]>
  }




  export type EmailAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAttachmentWhereInput
    orderBy?: EmailAttachmentOrderByWithAggregationInput | EmailAttachmentOrderByWithAggregationInput[]
    by: EmailAttachmentScalarFieldEnum[] | EmailAttachmentScalarFieldEnum
    having?: EmailAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAttachmentCountAggregateInputType | true
    _avg?: EmailAttachmentAvgAggregateInputType
    _sum?: EmailAttachmentSumAggregateInputType
    _min?: EmailAttachmentMinAggregateInputType
    _max?: EmailAttachmentMaxAggregateInputType
  }

  export type EmailAttachmentGroupByOutputType = {
    id: number
    emailId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    contentId: string | null
    createdAt: Date
    _count: EmailAttachmentCountAggregateOutputType | null
    _avg: EmailAttachmentAvgAggregateOutputType | null
    _sum: EmailAttachmentSumAggregateOutputType | null
    _min: EmailAttachmentMinAggregateOutputType | null
    _max: EmailAttachmentMaxAggregateOutputType | null
  }

  type GetEmailAttachmentGroupByPayload<T extends EmailAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type EmailAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    contentId?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAttachment"]>


  export type EmailAttachmentSelectScalar = {
    id?: boolean
    emailId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    contentId?: boolean
    createdAt?: boolean
  }

  export type EmailAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $EmailAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAttachment"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      emailId: number
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      contentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["emailAttachment"]>
    composites: {}
  }

  type EmailAttachmentGetPayload<S extends boolean | null | undefined | EmailAttachmentDefaultArgs> = $Result.GetResult<Prisma.$EmailAttachmentPayload, S>

  type EmailAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailAttachmentCountAggregateInputType | true
    }

  export interface EmailAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAttachment'], meta: { name: 'EmailAttachment' } }
    /**
     * Find zero or one EmailAttachment that matches the filter.
     * @param {EmailAttachmentFindUniqueArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAttachmentFindUniqueArgs>(args: SelectSubset<T, EmailAttachmentFindUniqueArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailAttachmentFindUniqueOrThrowArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindFirstArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAttachmentFindFirstArgs>(args?: SelectSubset<T, EmailAttachmentFindFirstArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindFirstOrThrowArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAttachments
     * const emailAttachments = await prisma.emailAttachment.findMany()
     * 
     * // Get first 10 EmailAttachments
     * const emailAttachments = await prisma.emailAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAttachmentWithIdOnly = await prisma.emailAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAttachmentFindManyArgs>(args?: SelectSubset<T, EmailAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailAttachment.
     * @param {EmailAttachmentCreateArgs} args - Arguments to create a EmailAttachment.
     * @example
     * // Create one EmailAttachment
     * const EmailAttachment = await prisma.emailAttachment.create({
     *   data: {
     *     // ... data to create a EmailAttachment
     *   }
     * })
     * 
     */
    create<T extends EmailAttachmentCreateArgs>(args: SelectSubset<T, EmailAttachmentCreateArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailAttachments.
     * @param {EmailAttachmentCreateManyArgs} args - Arguments to create many EmailAttachments.
     * @example
     * // Create many EmailAttachments
     * const emailAttachment = await prisma.emailAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAttachmentCreateManyArgs>(args?: SelectSubset<T, EmailAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailAttachment.
     * @param {EmailAttachmentDeleteArgs} args - Arguments to delete one EmailAttachment.
     * @example
     * // Delete one EmailAttachment
     * const EmailAttachment = await prisma.emailAttachment.delete({
     *   where: {
     *     // ... filter to delete one EmailAttachment
     *   }
     * })
     * 
     */
    delete<T extends EmailAttachmentDeleteArgs>(args: SelectSubset<T, EmailAttachmentDeleteArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailAttachment.
     * @param {EmailAttachmentUpdateArgs} args - Arguments to update one EmailAttachment.
     * @example
     * // Update one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAttachmentUpdateArgs>(args: SelectSubset<T, EmailAttachmentUpdateArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailAttachments.
     * @param {EmailAttachmentDeleteManyArgs} args - Arguments to filter EmailAttachments to delete.
     * @example
     * // Delete a few EmailAttachments
     * const { count } = await prisma.emailAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAttachmentDeleteManyArgs>(args?: SelectSubset<T, EmailAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAttachments
     * const emailAttachment = await prisma.emailAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAttachmentUpdateManyArgs>(args: SelectSubset<T, EmailAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailAttachment.
     * @param {EmailAttachmentUpsertArgs} args - Arguments to update or create a EmailAttachment.
     * @example
     * // Update or create a EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.upsert({
     *   create: {
     *     // ... data to create a EmailAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAttachment we want to update
     *   }
     * })
     */
    upsert<T extends EmailAttachmentUpsertArgs>(args: SelectSubset<T, EmailAttachmentUpsertArgs<ExtArgs>>): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentCountArgs} args - Arguments to filter EmailAttachments to count.
     * @example
     * // Count the number of EmailAttachments
     * const count = await prisma.emailAttachment.count({
     *   where: {
     *     // ... the filter for the EmailAttachments we want to count
     *   }
     * })
    **/
    count<T extends EmailAttachmentCountArgs>(
      args?: Subset<T, EmailAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAttachmentAggregateArgs>(args: Subset<T, EmailAttachmentAggregateArgs>): Prisma.PrismaPromise<GetEmailAttachmentAggregateType<T>>

    /**
     * Group by EmailAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: EmailAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAttachment model
   */
  readonly fields: EmailAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAttachment model
   */ 
  interface EmailAttachmentFieldRefs {
    readonly id: FieldRef<"EmailAttachment", 'Int'>
    readonly emailId: FieldRef<"EmailAttachment", 'Int'>
    readonly fileName: FieldRef<"EmailAttachment", 'String'>
    readonly filePath: FieldRef<"EmailAttachment", 'String'>
    readonly fileSize: FieldRef<"EmailAttachment", 'Int'>
    readonly mimeType: FieldRef<"EmailAttachment", 'String'>
    readonly contentId: FieldRef<"EmailAttachment", 'String'>
    readonly createdAt: FieldRef<"EmailAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAttachment findUnique
   */
  export type EmailAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment findUniqueOrThrow
   */
  export type EmailAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment findFirst
   */
  export type EmailAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAttachments.
     */
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * EmailAttachment findFirstOrThrow
   */
  export type EmailAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAttachments.
     */
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * EmailAttachment findMany
   */
  export type EmailAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachments to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }

  /**
   * EmailAttachment create
   */
  export type EmailAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAttachment.
     */
    data: XOR<EmailAttachmentCreateInput, EmailAttachmentUncheckedCreateInput>
  }

  /**
   * EmailAttachment createMany
   */
  export type EmailAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAttachments.
     */
    data: EmailAttachmentCreateManyInput | EmailAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAttachment update
   */
  export type EmailAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAttachment.
     */
    data: XOR<EmailAttachmentUpdateInput, EmailAttachmentUncheckedUpdateInput>
    /**
     * Choose, which EmailAttachment to update.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment updateMany
   */
  export type EmailAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAttachments.
     */
    data: XOR<EmailAttachmentUpdateManyMutationInput, EmailAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which EmailAttachments to update
     */
    where?: EmailAttachmentWhereInput
  }

  /**
   * EmailAttachment upsert
   */
  export type EmailAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAttachment to update in case it exists.
     */
    where: EmailAttachmentWhereUniqueInput
    /**
     * In case the EmailAttachment found by the `where` argument doesn't exist, create a new EmailAttachment with this data.
     */
    create: XOR<EmailAttachmentCreateInput, EmailAttachmentUncheckedCreateInput>
    /**
     * In case the EmailAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAttachmentUpdateInput, EmailAttachmentUncheckedUpdateInput>
  }

  /**
   * EmailAttachment delete
   */
  export type EmailAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter which EmailAttachment to delete.
     */
    where: EmailAttachmentWhereUniqueInput
  }

  /**
   * EmailAttachment deleteMany
   */
  export type EmailAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAttachments to delete
     */
    where?: EmailAttachmentWhereInput
  }

  /**
   * EmailAttachment without action
   */
  export type EmailAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model OAuthApplication
   */

  export type AggregateOAuthApplication = {
    _count: OAuthApplicationCountAggregateOutputType | null
    _avg: OAuthApplicationAvgAggregateOutputType | null
    _sum: OAuthApplicationSumAggregateOutputType | null
    _min: OAuthApplicationMinAggregateOutputType | null
    _max: OAuthApplicationMaxAggregateOutputType | null
  }

  export type OAuthApplicationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OAuthApplicationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type OAuthApplicationMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    website: string | null
    clientId: string | null
    clientSecret: string | null
    redirectUris: string | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthApplicationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    website: string | null
    clientId: string | null
    clientSecret: string | null
    redirectUris: string | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthApplicationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    website: number
    clientId: number
    clientSecret: number
    redirectUris: number
    userId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OAuthApplicationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OAuthApplicationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type OAuthApplicationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    clientId?: true
    clientSecret?: true
    redirectUris?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthApplicationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    clientId?: true
    clientSecret?: true
    redirectUris?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthApplicationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    clientId?: true
    clientSecret?: true
    redirectUris?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OAuthApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthApplication to aggregate.
     */
    where?: OAuthApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApplications to fetch.
     */
    orderBy?: OAuthApplicationOrderByWithRelationInput | OAuthApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthApplications
    **/
    _count?: true | OAuthApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OAuthApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OAuthApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthApplicationMaxAggregateInputType
  }

  export type GetOAuthApplicationAggregateType<T extends OAuthApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthApplication[P]>
      : GetScalarType<T[P], AggregateOAuthApplication[P]>
  }




  export type OAuthApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthApplicationWhereInput
    orderBy?: OAuthApplicationOrderByWithAggregationInput | OAuthApplicationOrderByWithAggregationInput[]
    by: OAuthApplicationScalarFieldEnum[] | OAuthApplicationScalarFieldEnum
    having?: OAuthApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthApplicationCountAggregateInputType | true
    _avg?: OAuthApplicationAvgAggregateInputType
    _sum?: OAuthApplicationSumAggregateInputType
    _min?: OAuthApplicationMinAggregateInputType
    _max?: OAuthApplicationMaxAggregateInputType
  }

  export type OAuthApplicationGroupByOutputType = {
    id: number
    name: string
    description: string | null
    website: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    userId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OAuthApplicationCountAggregateOutputType | null
    _avg: OAuthApplicationAvgAggregateOutputType | null
    _sum: OAuthApplicationSumAggregateOutputType | null
    _min: OAuthApplicationMinAggregateOutputType | null
    _max: OAuthApplicationMaxAggregateOutputType | null
  }

  type GetOAuthApplicationGroupByPayload<T extends OAuthApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthApplicationGroupByOutputType[P]>
        }
      >
    >


  export type OAuthApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUris?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    authCodes?: boolean | OAuthApplication$authCodesArgs<ExtArgs>
    accessTokens?: boolean | OAuthApplication$accessTokensArgs<ExtArgs>
    _count?: boolean | OAuthApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthApplication"]>


  export type OAuthApplicationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    clientId?: boolean
    clientSecret?: boolean
    redirectUris?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OAuthApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    authCodes?: boolean | OAuthApplication$authCodesArgs<ExtArgs>
    accessTokens?: boolean | OAuthApplication$accessTokensArgs<ExtArgs>
    _count?: boolean | OAuthApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OAuthApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      authCodes: Prisma.$OAuthAuthCodePayload<ExtArgs>[]
      accessTokens: Prisma.$OAuthAccessTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      website: string | null
      clientId: string
      clientSecret: string
      redirectUris: string
      userId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oAuthApplication"]>
    composites: {}
  }

  type OAuthApplicationGetPayload<S extends boolean | null | undefined | OAuthApplicationDefaultArgs> = $Result.GetResult<Prisma.$OAuthApplicationPayload, S>

  type OAuthApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthApplicationCountAggregateInputType | true
    }

  export interface OAuthApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthApplication'], meta: { name: 'OAuthApplication' } }
    /**
     * Find zero or one OAuthApplication that matches the filter.
     * @param {OAuthApplicationFindUniqueArgs} args - Arguments to find a OAuthApplication
     * @example
     * // Get one OAuthApplication
     * const oAuthApplication = await prisma.oAuthApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthApplicationFindUniqueArgs>(args: SelectSubset<T, OAuthApplicationFindUniqueArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthApplicationFindUniqueOrThrowArgs} args - Arguments to find a OAuthApplication
     * @example
     * // Get one OAuthApplication
     * const oAuthApplication = await prisma.oAuthApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthApplicationFindFirstArgs} args - Arguments to find a OAuthApplication
     * @example
     * // Get one OAuthApplication
     * const oAuthApplication = await prisma.oAuthApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthApplicationFindFirstArgs>(args?: SelectSubset<T, OAuthApplicationFindFirstArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthApplicationFindFirstOrThrowArgs} args - Arguments to find a OAuthApplication
     * @example
     * // Get one OAuthApplication
     * const oAuthApplication = await prisma.oAuthApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthApplications
     * const oAuthApplications = await prisma.oAuthApplication.findMany()
     * 
     * // Get first 10 OAuthApplications
     * const oAuthApplications = await prisma.oAuthApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthApplicationWithIdOnly = await prisma.oAuthApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthApplicationFindManyArgs>(args?: SelectSubset<T, OAuthApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthApplication.
     * @param {OAuthApplicationCreateArgs} args - Arguments to create a OAuthApplication.
     * @example
     * // Create one OAuthApplication
     * const OAuthApplication = await prisma.oAuthApplication.create({
     *   data: {
     *     // ... data to create a OAuthApplication
     *   }
     * })
     * 
     */
    create<T extends OAuthApplicationCreateArgs>(args: SelectSubset<T, OAuthApplicationCreateArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthApplications.
     * @param {OAuthApplicationCreateManyArgs} args - Arguments to create many OAuthApplications.
     * @example
     * // Create many OAuthApplications
     * const oAuthApplication = await prisma.oAuthApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthApplicationCreateManyArgs>(args?: SelectSubset<T, OAuthApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthApplication.
     * @param {OAuthApplicationDeleteArgs} args - Arguments to delete one OAuthApplication.
     * @example
     * // Delete one OAuthApplication
     * const OAuthApplication = await prisma.oAuthApplication.delete({
     *   where: {
     *     // ... filter to delete one OAuthApplication
     *   }
     * })
     * 
     */
    delete<T extends OAuthApplicationDeleteArgs>(args: SelectSubset<T, OAuthApplicationDeleteArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthApplication.
     * @param {OAuthApplicationUpdateArgs} args - Arguments to update one OAuthApplication.
     * @example
     * // Update one OAuthApplication
     * const oAuthApplication = await prisma.oAuthApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthApplicationUpdateArgs>(args: SelectSubset<T, OAuthApplicationUpdateArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthApplications.
     * @param {OAuthApplicationDeleteManyArgs} args - Arguments to filter OAuthApplications to delete.
     * @example
     * // Delete a few OAuthApplications
     * const { count } = await prisma.oAuthApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthApplicationDeleteManyArgs>(args?: SelectSubset<T, OAuthApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthApplications
     * const oAuthApplication = await prisma.oAuthApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthApplicationUpdateManyArgs>(args: SelectSubset<T, OAuthApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthApplication.
     * @param {OAuthApplicationUpsertArgs} args - Arguments to update or create a OAuthApplication.
     * @example
     * // Update or create a OAuthApplication
     * const oAuthApplication = await prisma.oAuthApplication.upsert({
     *   create: {
     *     // ... data to create a OAuthApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthApplication we want to update
     *   }
     * })
     */
    upsert<T extends OAuthApplicationUpsertArgs>(args: SelectSubset<T, OAuthApplicationUpsertArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthApplicationCountArgs} args - Arguments to filter OAuthApplications to count.
     * @example
     * // Count the number of OAuthApplications
     * const count = await prisma.oAuthApplication.count({
     *   where: {
     *     // ... the filter for the OAuthApplications we want to count
     *   }
     * })
    **/
    count<T extends OAuthApplicationCountArgs>(
      args?: Subset<T, OAuthApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthApplicationAggregateArgs>(args: Subset<T, OAuthApplicationAggregateArgs>): Prisma.PrismaPromise<GetOAuthApplicationAggregateType<T>>

    /**
     * Group by OAuthApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthApplicationGroupByArgs['orderBy'] }
        : { orderBy?: OAuthApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthApplication model
   */
  readonly fields: OAuthApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    authCodes<T extends OAuthApplication$authCodesArgs<ExtArgs> = {}>(args?: Subset<T, OAuthApplication$authCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "findMany"> | Null>
    accessTokens<T extends OAuthApplication$accessTokensArgs<ExtArgs> = {}>(args?: Subset<T, OAuthApplication$accessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthApplication model
   */ 
  interface OAuthApplicationFieldRefs {
    readonly id: FieldRef<"OAuthApplication", 'Int'>
    readonly name: FieldRef<"OAuthApplication", 'String'>
    readonly description: FieldRef<"OAuthApplication", 'String'>
    readonly website: FieldRef<"OAuthApplication", 'String'>
    readonly clientId: FieldRef<"OAuthApplication", 'String'>
    readonly clientSecret: FieldRef<"OAuthApplication", 'String'>
    readonly redirectUris: FieldRef<"OAuthApplication", 'String'>
    readonly userId: FieldRef<"OAuthApplication", 'Int'>
    readonly isActive: FieldRef<"OAuthApplication", 'Boolean'>
    readonly createdAt: FieldRef<"OAuthApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"OAuthApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthApplication findUnique
   */
  export type OAuthApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApplication to fetch.
     */
    where: OAuthApplicationWhereUniqueInput
  }

  /**
   * OAuthApplication findUniqueOrThrow
   */
  export type OAuthApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApplication to fetch.
     */
    where: OAuthApplicationWhereUniqueInput
  }

  /**
   * OAuthApplication findFirst
   */
  export type OAuthApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApplication to fetch.
     */
    where?: OAuthApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApplications to fetch.
     */
    orderBy?: OAuthApplicationOrderByWithRelationInput | OAuthApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthApplications.
     */
    cursor?: OAuthApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthApplications.
     */
    distinct?: OAuthApplicationScalarFieldEnum | OAuthApplicationScalarFieldEnum[]
  }

  /**
   * OAuthApplication findFirstOrThrow
   */
  export type OAuthApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApplication to fetch.
     */
    where?: OAuthApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApplications to fetch.
     */
    orderBy?: OAuthApplicationOrderByWithRelationInput | OAuthApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthApplications.
     */
    cursor?: OAuthApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthApplications.
     */
    distinct?: OAuthApplicationScalarFieldEnum | OAuthApplicationScalarFieldEnum[]
  }

  /**
   * OAuthApplication findMany
   */
  export type OAuthApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthApplications to fetch.
     */
    where?: OAuthApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthApplications to fetch.
     */
    orderBy?: OAuthApplicationOrderByWithRelationInput | OAuthApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthApplications.
     */
    cursor?: OAuthApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthApplications.
     */
    skip?: number
    distinct?: OAuthApplicationScalarFieldEnum | OAuthApplicationScalarFieldEnum[]
  }

  /**
   * OAuthApplication create
   */
  export type OAuthApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthApplication.
     */
    data: XOR<OAuthApplicationCreateInput, OAuthApplicationUncheckedCreateInput>
  }

  /**
   * OAuthApplication createMany
   */
  export type OAuthApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthApplications.
     */
    data: OAuthApplicationCreateManyInput | OAuthApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthApplication update
   */
  export type OAuthApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthApplication.
     */
    data: XOR<OAuthApplicationUpdateInput, OAuthApplicationUncheckedUpdateInput>
    /**
     * Choose, which OAuthApplication to update.
     */
    where: OAuthApplicationWhereUniqueInput
  }

  /**
   * OAuthApplication updateMany
   */
  export type OAuthApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthApplications.
     */
    data: XOR<OAuthApplicationUpdateManyMutationInput, OAuthApplicationUncheckedUpdateManyInput>
    /**
     * Filter which OAuthApplications to update
     */
    where?: OAuthApplicationWhereInput
  }

  /**
   * OAuthApplication upsert
   */
  export type OAuthApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthApplication to update in case it exists.
     */
    where: OAuthApplicationWhereUniqueInput
    /**
     * In case the OAuthApplication found by the `where` argument doesn't exist, create a new OAuthApplication with this data.
     */
    create: XOR<OAuthApplicationCreateInput, OAuthApplicationUncheckedCreateInput>
    /**
     * In case the OAuthApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthApplicationUpdateInput, OAuthApplicationUncheckedUpdateInput>
  }

  /**
   * OAuthApplication delete
   */
  export type OAuthApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
    /**
     * Filter which OAuthApplication to delete.
     */
    where: OAuthApplicationWhereUniqueInput
  }

  /**
   * OAuthApplication deleteMany
   */
  export type OAuthApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthApplications to delete
     */
    where?: OAuthApplicationWhereInput
  }

  /**
   * OAuthApplication.authCodes
   */
  export type OAuthApplication$authCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    where?: OAuthAuthCodeWhereInput
    orderBy?: OAuthAuthCodeOrderByWithRelationInput | OAuthAuthCodeOrderByWithRelationInput[]
    cursor?: OAuthAuthCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAuthCodeScalarFieldEnum | OAuthAuthCodeScalarFieldEnum[]
  }

  /**
   * OAuthApplication.accessTokens
   */
  export type OAuthApplication$accessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    where?: OAuthAccessTokenWhereInput
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    cursor?: OAuthAccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }

  /**
   * OAuthApplication without action
   */
  export type OAuthApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthApplication
     */
    select?: OAuthApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthApplicationInclude<ExtArgs> | null
  }


  /**
   * Model OAuthAuthCode
   */

  export type AggregateOAuthAuthCode = {
    _count: OAuthAuthCodeCountAggregateOutputType | null
    _avg: OAuthAuthCodeAvgAggregateOutputType | null
    _sum: OAuthAuthCodeSumAggregateOutputType | null
    _min: OAuthAuthCodeMinAggregateOutputType | null
    _max: OAuthAuthCodeMaxAggregateOutputType | null
  }

  export type OAuthAuthCodeAvgAggregateOutputType = {
    id: number | null
    applicationId: number | null
    userId: number | null
  }

  export type OAuthAuthCodeSumAggregateOutputType = {
    id: number | null
    applicationId: number | null
    userId: number | null
  }

  export type OAuthAuthCodeMinAggregateOutputType = {
    id: number | null
    code: string | null
    applicationId: number | null
    userId: number | null
    redirectUri: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type OAuthAuthCodeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    applicationId: number | null
    userId: number | null
    redirectUri: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type OAuthAuthCodeCountAggregateOutputType = {
    id: number
    code: number
    applicationId: number
    userId: number
    redirectUri: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type OAuthAuthCodeAvgAggregateInputType = {
    id?: true
    applicationId?: true
    userId?: true
  }

  export type OAuthAuthCodeSumAggregateInputType = {
    id?: true
    applicationId?: true
    userId?: true
  }

  export type OAuthAuthCodeMinAggregateInputType = {
    id?: true
    code?: true
    applicationId?: true
    userId?: true
    redirectUri?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type OAuthAuthCodeMaxAggregateInputType = {
    id?: true
    code?: true
    applicationId?: true
    userId?: true
    redirectUri?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type OAuthAuthCodeCountAggregateInputType = {
    id?: true
    code?: true
    applicationId?: true
    userId?: true
    redirectUri?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type OAuthAuthCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAuthCode to aggregate.
     */
    where?: OAuthAuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthCodes to fetch.
     */
    orderBy?: OAuthAuthCodeOrderByWithRelationInput | OAuthAuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthAuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthAuthCodes
    **/
    _count?: true | OAuthAuthCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OAuthAuthCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OAuthAuthCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthAuthCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthAuthCodeMaxAggregateInputType
  }

  export type GetOAuthAuthCodeAggregateType<T extends OAuthAuthCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthAuthCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthAuthCode[P]>
      : GetScalarType<T[P], AggregateOAuthAuthCode[P]>
  }




  export type OAuthAuthCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAuthCodeWhereInput
    orderBy?: OAuthAuthCodeOrderByWithAggregationInput | OAuthAuthCodeOrderByWithAggregationInput[]
    by: OAuthAuthCodeScalarFieldEnum[] | OAuthAuthCodeScalarFieldEnum
    having?: OAuthAuthCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthAuthCodeCountAggregateInputType | true
    _avg?: OAuthAuthCodeAvgAggregateInputType
    _sum?: OAuthAuthCodeSumAggregateInputType
    _min?: OAuthAuthCodeMinAggregateInputType
    _max?: OAuthAuthCodeMaxAggregateInputType
  }

  export type OAuthAuthCodeGroupByOutputType = {
    id: number
    code: string
    applicationId: number
    userId: number
    redirectUri: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: OAuthAuthCodeCountAggregateOutputType | null
    _avg: OAuthAuthCodeAvgAggregateOutputType | null
    _sum: OAuthAuthCodeSumAggregateOutputType | null
    _min: OAuthAuthCodeMinAggregateOutputType | null
    _max: OAuthAuthCodeMaxAggregateOutputType | null
  }

  type GetOAuthAuthCodeGroupByPayload<T extends OAuthAuthCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthAuthCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthAuthCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthAuthCodeGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthAuthCodeGroupByOutputType[P]>
        }
      >
    >


  export type OAuthAuthCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    applicationId?: boolean
    userId?: boolean
    redirectUri?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    application?: boolean | OAuthApplicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthAuthCode"]>


  export type OAuthAuthCodeSelectScalar = {
    id?: boolean
    code?: boolean
    applicationId?: boolean
    userId?: boolean
    redirectUri?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type OAuthAuthCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | OAuthApplicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OAuthAuthCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthAuthCode"
    objects: {
      application: Prisma.$OAuthApplicationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      applicationId: number
      userId: number
      redirectUri: string
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["oAuthAuthCode"]>
    composites: {}
  }

  type OAuthAuthCodeGetPayload<S extends boolean | null | undefined | OAuthAuthCodeDefaultArgs> = $Result.GetResult<Prisma.$OAuthAuthCodePayload, S>

  type OAuthAuthCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthAuthCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthAuthCodeCountAggregateInputType | true
    }

  export interface OAuthAuthCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthAuthCode'], meta: { name: 'OAuthAuthCode' } }
    /**
     * Find zero or one OAuthAuthCode that matches the filter.
     * @param {OAuthAuthCodeFindUniqueArgs} args - Arguments to find a OAuthAuthCode
     * @example
     * // Get one OAuthAuthCode
     * const oAuthAuthCode = await prisma.oAuthAuthCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthAuthCodeFindUniqueArgs>(args: SelectSubset<T, OAuthAuthCodeFindUniqueArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthAuthCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthAuthCodeFindUniqueOrThrowArgs} args - Arguments to find a OAuthAuthCode
     * @example
     * // Get one OAuthAuthCode
     * const oAuthAuthCode = await prisma.oAuthAuthCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthAuthCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthAuthCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthAuthCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthCodeFindFirstArgs} args - Arguments to find a OAuthAuthCode
     * @example
     * // Get one OAuthAuthCode
     * const oAuthAuthCode = await prisma.oAuthAuthCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthAuthCodeFindFirstArgs>(args?: SelectSubset<T, OAuthAuthCodeFindFirstArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthAuthCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthCodeFindFirstOrThrowArgs} args - Arguments to find a OAuthAuthCode
     * @example
     * // Get one OAuthAuthCode
     * const oAuthAuthCode = await prisma.oAuthAuthCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthAuthCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthAuthCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthAuthCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthAuthCodes
     * const oAuthAuthCodes = await prisma.oAuthAuthCode.findMany()
     * 
     * // Get first 10 OAuthAuthCodes
     * const oAuthAuthCodes = await prisma.oAuthAuthCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthAuthCodeWithIdOnly = await prisma.oAuthAuthCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthAuthCodeFindManyArgs>(args?: SelectSubset<T, OAuthAuthCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthAuthCode.
     * @param {OAuthAuthCodeCreateArgs} args - Arguments to create a OAuthAuthCode.
     * @example
     * // Create one OAuthAuthCode
     * const OAuthAuthCode = await prisma.oAuthAuthCode.create({
     *   data: {
     *     // ... data to create a OAuthAuthCode
     *   }
     * })
     * 
     */
    create<T extends OAuthAuthCodeCreateArgs>(args: SelectSubset<T, OAuthAuthCodeCreateArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthAuthCodes.
     * @param {OAuthAuthCodeCreateManyArgs} args - Arguments to create many OAuthAuthCodes.
     * @example
     * // Create many OAuthAuthCodes
     * const oAuthAuthCode = await prisma.oAuthAuthCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthAuthCodeCreateManyArgs>(args?: SelectSubset<T, OAuthAuthCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthAuthCode.
     * @param {OAuthAuthCodeDeleteArgs} args - Arguments to delete one OAuthAuthCode.
     * @example
     * // Delete one OAuthAuthCode
     * const OAuthAuthCode = await prisma.oAuthAuthCode.delete({
     *   where: {
     *     // ... filter to delete one OAuthAuthCode
     *   }
     * })
     * 
     */
    delete<T extends OAuthAuthCodeDeleteArgs>(args: SelectSubset<T, OAuthAuthCodeDeleteArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthAuthCode.
     * @param {OAuthAuthCodeUpdateArgs} args - Arguments to update one OAuthAuthCode.
     * @example
     * // Update one OAuthAuthCode
     * const oAuthAuthCode = await prisma.oAuthAuthCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthAuthCodeUpdateArgs>(args: SelectSubset<T, OAuthAuthCodeUpdateArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthAuthCodes.
     * @param {OAuthAuthCodeDeleteManyArgs} args - Arguments to filter OAuthAuthCodes to delete.
     * @example
     * // Delete a few OAuthAuthCodes
     * const { count } = await prisma.oAuthAuthCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthAuthCodeDeleteManyArgs>(args?: SelectSubset<T, OAuthAuthCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthAuthCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthAuthCodes
     * const oAuthAuthCode = await prisma.oAuthAuthCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthAuthCodeUpdateManyArgs>(args: SelectSubset<T, OAuthAuthCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthAuthCode.
     * @param {OAuthAuthCodeUpsertArgs} args - Arguments to update or create a OAuthAuthCode.
     * @example
     * // Update or create a OAuthAuthCode
     * const oAuthAuthCode = await prisma.oAuthAuthCode.upsert({
     *   create: {
     *     // ... data to create a OAuthAuthCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthAuthCode we want to update
     *   }
     * })
     */
    upsert<T extends OAuthAuthCodeUpsertArgs>(args: SelectSubset<T, OAuthAuthCodeUpsertArgs<ExtArgs>>): Prisma__OAuthAuthCodeClient<$Result.GetResult<Prisma.$OAuthAuthCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthAuthCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthCodeCountArgs} args - Arguments to filter OAuthAuthCodes to count.
     * @example
     * // Count the number of OAuthAuthCodes
     * const count = await prisma.oAuthAuthCode.count({
     *   where: {
     *     // ... the filter for the OAuthAuthCodes we want to count
     *   }
     * })
    **/
    count<T extends OAuthAuthCodeCountArgs>(
      args?: Subset<T, OAuthAuthCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthAuthCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthAuthCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthAuthCodeAggregateArgs>(args: Subset<T, OAuthAuthCodeAggregateArgs>): Prisma.PrismaPromise<GetOAuthAuthCodeAggregateType<T>>

    /**
     * Group by OAuthAuthCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthAuthCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthAuthCodeGroupByArgs['orderBy'] }
        : { orderBy?: OAuthAuthCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthAuthCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthAuthCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthAuthCode model
   */
  readonly fields: OAuthAuthCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthAuthCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthAuthCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends OAuthApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OAuthApplicationDefaultArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthAuthCode model
   */ 
  interface OAuthAuthCodeFieldRefs {
    readonly id: FieldRef<"OAuthAuthCode", 'Int'>
    readonly code: FieldRef<"OAuthAuthCode", 'String'>
    readonly applicationId: FieldRef<"OAuthAuthCode", 'Int'>
    readonly userId: FieldRef<"OAuthAuthCode", 'Int'>
    readonly redirectUri: FieldRef<"OAuthAuthCode", 'String'>
    readonly expiresAt: FieldRef<"OAuthAuthCode", 'DateTime'>
    readonly used: FieldRef<"OAuthAuthCode", 'Boolean'>
    readonly createdAt: FieldRef<"OAuthAuthCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthAuthCode findUnique
   */
  export type OAuthAuthCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthCode to fetch.
     */
    where: OAuthAuthCodeWhereUniqueInput
  }

  /**
   * OAuthAuthCode findUniqueOrThrow
   */
  export type OAuthAuthCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthCode to fetch.
     */
    where: OAuthAuthCodeWhereUniqueInput
  }

  /**
   * OAuthAuthCode findFirst
   */
  export type OAuthAuthCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthCode to fetch.
     */
    where?: OAuthAuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthCodes to fetch.
     */
    orderBy?: OAuthAuthCodeOrderByWithRelationInput | OAuthAuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAuthCodes.
     */
    cursor?: OAuthAuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAuthCodes.
     */
    distinct?: OAuthAuthCodeScalarFieldEnum | OAuthAuthCodeScalarFieldEnum[]
  }

  /**
   * OAuthAuthCode findFirstOrThrow
   */
  export type OAuthAuthCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthCode to fetch.
     */
    where?: OAuthAuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthCodes to fetch.
     */
    orderBy?: OAuthAuthCodeOrderByWithRelationInput | OAuthAuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAuthCodes.
     */
    cursor?: OAuthAuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAuthCodes.
     */
    distinct?: OAuthAuthCodeScalarFieldEnum | OAuthAuthCodeScalarFieldEnum[]
  }

  /**
   * OAuthAuthCode findMany
   */
  export type OAuthAuthCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthCodes to fetch.
     */
    where?: OAuthAuthCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthCodes to fetch.
     */
    orderBy?: OAuthAuthCodeOrderByWithRelationInput | OAuthAuthCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthAuthCodes.
     */
    cursor?: OAuthAuthCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthCodes.
     */
    skip?: number
    distinct?: OAuthAuthCodeScalarFieldEnum | OAuthAuthCodeScalarFieldEnum[]
  }

  /**
   * OAuthAuthCode create
   */
  export type OAuthAuthCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthAuthCode.
     */
    data: XOR<OAuthAuthCodeCreateInput, OAuthAuthCodeUncheckedCreateInput>
  }

  /**
   * OAuthAuthCode createMany
   */
  export type OAuthAuthCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthAuthCodes.
     */
    data: OAuthAuthCodeCreateManyInput | OAuthAuthCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthAuthCode update
   */
  export type OAuthAuthCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthAuthCode.
     */
    data: XOR<OAuthAuthCodeUpdateInput, OAuthAuthCodeUncheckedUpdateInput>
    /**
     * Choose, which OAuthAuthCode to update.
     */
    where: OAuthAuthCodeWhereUniqueInput
  }

  /**
   * OAuthAuthCode updateMany
   */
  export type OAuthAuthCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthAuthCodes.
     */
    data: XOR<OAuthAuthCodeUpdateManyMutationInput, OAuthAuthCodeUncheckedUpdateManyInput>
    /**
     * Filter which OAuthAuthCodes to update
     */
    where?: OAuthAuthCodeWhereInput
  }

  /**
   * OAuthAuthCode upsert
   */
  export type OAuthAuthCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthAuthCode to update in case it exists.
     */
    where: OAuthAuthCodeWhereUniqueInput
    /**
     * In case the OAuthAuthCode found by the `where` argument doesn't exist, create a new OAuthAuthCode with this data.
     */
    create: XOR<OAuthAuthCodeCreateInput, OAuthAuthCodeUncheckedCreateInput>
    /**
     * In case the OAuthAuthCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthAuthCodeUpdateInput, OAuthAuthCodeUncheckedUpdateInput>
  }

  /**
   * OAuthAuthCode delete
   */
  export type OAuthAuthCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
    /**
     * Filter which OAuthAuthCode to delete.
     */
    where: OAuthAuthCodeWhereUniqueInput
  }

  /**
   * OAuthAuthCode deleteMany
   */
  export type OAuthAuthCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAuthCodes to delete
     */
    where?: OAuthAuthCodeWhereInput
  }

  /**
   * OAuthAuthCode without action
   */
  export type OAuthAuthCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthCode
     */
    select?: OAuthAuthCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAuthCodeInclude<ExtArgs> | null
  }


  /**
   * Model OAuthAccessToken
   */

  export type AggregateOAuthAccessToken = {
    _count: OAuthAccessTokenCountAggregateOutputType | null
    _avg: OAuthAccessTokenAvgAggregateOutputType | null
    _sum: OAuthAccessTokenSumAggregateOutputType | null
    _min: OAuthAccessTokenMinAggregateOutputType | null
    _max: OAuthAccessTokenMaxAggregateOutputType | null
  }

  export type OAuthAccessTokenAvgAggregateOutputType = {
    id: number | null
    applicationId: number | null
    userId: number | null
  }

  export type OAuthAccessTokenSumAggregateOutputType = {
    id: number | null
    applicationId: number | null
    userId: number | null
  }

  export type OAuthAccessTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    refreshToken: string | null
    applicationId: number | null
    userId: number | null
    scope: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthAccessTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    refreshToken: string | null
    applicationId: number | null
    userId: number | null
    scope: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthAccessTokenCountAggregateOutputType = {
    id: number
    token: number
    refreshToken: number
    applicationId: number
    userId: number
    scope: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OAuthAccessTokenAvgAggregateInputType = {
    id?: true
    applicationId?: true
    userId?: true
  }

  export type OAuthAccessTokenSumAggregateInputType = {
    id?: true
    applicationId?: true
    userId?: true
  }

  export type OAuthAccessTokenMinAggregateInputType = {
    id?: true
    token?: true
    refreshToken?: true
    applicationId?: true
    userId?: true
    scope?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthAccessTokenMaxAggregateInputType = {
    id?: true
    token?: true
    refreshToken?: true
    applicationId?: true
    userId?: true
    scope?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthAccessTokenCountAggregateInputType = {
    id?: true
    token?: true
    refreshToken?: true
    applicationId?: true
    userId?: true
    scope?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OAuthAccessTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAccessToken to aggregate.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthAccessTokens
    **/
    _count?: true | OAuthAccessTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OAuthAccessTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OAuthAccessTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthAccessTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthAccessTokenMaxAggregateInputType
  }

  export type GetOAuthAccessTokenAggregateType<T extends OAuthAccessTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthAccessToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthAccessToken[P]>
      : GetScalarType<T[P], AggregateOAuthAccessToken[P]>
  }




  export type OAuthAccessTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAccessTokenWhereInput
    orderBy?: OAuthAccessTokenOrderByWithAggregationInput | OAuthAccessTokenOrderByWithAggregationInput[]
    by: OAuthAccessTokenScalarFieldEnum[] | OAuthAccessTokenScalarFieldEnum
    having?: OAuthAccessTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthAccessTokenCountAggregateInputType | true
    _avg?: OAuthAccessTokenAvgAggregateInputType
    _sum?: OAuthAccessTokenSumAggregateInputType
    _min?: OAuthAccessTokenMinAggregateInputType
    _max?: OAuthAccessTokenMaxAggregateInputType
  }

  export type OAuthAccessTokenGroupByOutputType = {
    id: number
    token: string
    refreshToken: string | null
    applicationId: number
    userId: number
    scope: string | null
    expiresAt: Date
    createdAt: Date
    _count: OAuthAccessTokenCountAggregateOutputType | null
    _avg: OAuthAccessTokenAvgAggregateOutputType | null
    _sum: OAuthAccessTokenSumAggregateOutputType | null
    _min: OAuthAccessTokenMinAggregateOutputType | null
    _max: OAuthAccessTokenMaxAggregateOutputType | null
  }

  type GetOAuthAccessTokenGroupByPayload<T extends OAuthAccessTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthAccessTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthAccessTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthAccessTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthAccessTokenGroupByOutputType[P]>
        }
      >
    >


  export type OAuthAccessTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    refreshToken?: boolean
    applicationId?: boolean
    userId?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    application?: boolean | OAuthApplicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthAccessToken"]>


  export type OAuthAccessTokenSelectScalar = {
    id?: boolean
    token?: boolean
    refreshToken?: boolean
    applicationId?: boolean
    userId?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type OAuthAccessTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | OAuthApplicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OAuthAccessTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthAccessToken"
    objects: {
      application: Prisma.$OAuthApplicationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      refreshToken: string | null
      applicationId: number
      userId: number
      scope: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["oAuthAccessToken"]>
    composites: {}
  }

  type OAuthAccessTokenGetPayload<S extends boolean | null | undefined | OAuthAccessTokenDefaultArgs> = $Result.GetResult<Prisma.$OAuthAccessTokenPayload, S>

  type OAuthAccessTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthAccessTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthAccessTokenCountAggregateInputType | true
    }

  export interface OAuthAccessTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthAccessToken'], meta: { name: 'OAuthAccessToken' } }
    /**
     * Find zero or one OAuthAccessToken that matches the filter.
     * @param {OAuthAccessTokenFindUniqueArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthAccessTokenFindUniqueArgs>(args: SelectSubset<T, OAuthAccessTokenFindUniqueArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthAccessToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthAccessTokenFindUniqueOrThrowArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthAccessTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthAccessTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthAccessToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenFindFirstArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthAccessTokenFindFirstArgs>(args?: SelectSubset<T, OAuthAccessTokenFindFirstArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthAccessToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenFindFirstOrThrowArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthAccessTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthAccessTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthAccessTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthAccessTokens
     * const oAuthAccessTokens = await prisma.oAuthAccessToken.findMany()
     * 
     * // Get first 10 OAuthAccessTokens
     * const oAuthAccessTokens = await prisma.oAuthAccessToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthAccessTokenWithIdOnly = await prisma.oAuthAccessToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthAccessTokenFindManyArgs>(args?: SelectSubset<T, OAuthAccessTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthAccessToken.
     * @param {OAuthAccessTokenCreateArgs} args - Arguments to create a OAuthAccessToken.
     * @example
     * // Create one OAuthAccessToken
     * const OAuthAccessToken = await prisma.oAuthAccessToken.create({
     *   data: {
     *     // ... data to create a OAuthAccessToken
     *   }
     * })
     * 
     */
    create<T extends OAuthAccessTokenCreateArgs>(args: SelectSubset<T, OAuthAccessTokenCreateArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthAccessTokens.
     * @param {OAuthAccessTokenCreateManyArgs} args - Arguments to create many OAuthAccessTokens.
     * @example
     * // Create many OAuthAccessTokens
     * const oAuthAccessToken = await prisma.oAuthAccessToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthAccessTokenCreateManyArgs>(args?: SelectSubset<T, OAuthAccessTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthAccessToken.
     * @param {OAuthAccessTokenDeleteArgs} args - Arguments to delete one OAuthAccessToken.
     * @example
     * // Delete one OAuthAccessToken
     * const OAuthAccessToken = await prisma.oAuthAccessToken.delete({
     *   where: {
     *     // ... filter to delete one OAuthAccessToken
     *   }
     * })
     * 
     */
    delete<T extends OAuthAccessTokenDeleteArgs>(args: SelectSubset<T, OAuthAccessTokenDeleteArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthAccessToken.
     * @param {OAuthAccessTokenUpdateArgs} args - Arguments to update one OAuthAccessToken.
     * @example
     * // Update one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthAccessTokenUpdateArgs>(args: SelectSubset<T, OAuthAccessTokenUpdateArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthAccessTokens.
     * @param {OAuthAccessTokenDeleteManyArgs} args - Arguments to filter OAuthAccessTokens to delete.
     * @example
     * // Delete a few OAuthAccessTokens
     * const { count } = await prisma.oAuthAccessToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthAccessTokenDeleteManyArgs>(args?: SelectSubset<T, OAuthAccessTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthAccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthAccessTokens
     * const oAuthAccessToken = await prisma.oAuthAccessToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthAccessTokenUpdateManyArgs>(args: SelectSubset<T, OAuthAccessTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthAccessToken.
     * @param {OAuthAccessTokenUpsertArgs} args - Arguments to update or create a OAuthAccessToken.
     * @example
     * // Update or create a OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.upsert({
     *   create: {
     *     // ... data to create a OAuthAccessToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthAccessToken we want to update
     *   }
     * })
     */
    upsert<T extends OAuthAccessTokenUpsertArgs>(args: SelectSubset<T, OAuthAccessTokenUpsertArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Result.GetResult<Prisma.$OAuthAccessTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthAccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenCountArgs} args - Arguments to filter OAuthAccessTokens to count.
     * @example
     * // Count the number of OAuthAccessTokens
     * const count = await prisma.oAuthAccessToken.count({
     *   where: {
     *     // ... the filter for the OAuthAccessTokens we want to count
     *   }
     * })
    **/
    count<T extends OAuthAccessTokenCountArgs>(
      args?: Subset<T, OAuthAccessTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthAccessTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthAccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthAccessTokenAggregateArgs>(args: Subset<T, OAuthAccessTokenAggregateArgs>): Prisma.PrismaPromise<GetOAuthAccessTokenAggregateType<T>>

    /**
     * Group by OAuthAccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthAccessTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthAccessTokenGroupByArgs['orderBy'] }
        : { orderBy?: OAuthAccessTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthAccessTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthAccessTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthAccessToken model
   */
  readonly fields: OAuthAccessTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthAccessToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthAccessTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends OAuthApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OAuthApplicationDefaultArgs<ExtArgs>>): Prisma__OAuthApplicationClient<$Result.GetResult<Prisma.$OAuthApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthAccessToken model
   */ 
  interface OAuthAccessTokenFieldRefs {
    readonly id: FieldRef<"OAuthAccessToken", 'Int'>
    readonly token: FieldRef<"OAuthAccessToken", 'String'>
    readonly refreshToken: FieldRef<"OAuthAccessToken", 'String'>
    readonly applicationId: FieldRef<"OAuthAccessToken", 'Int'>
    readonly userId: FieldRef<"OAuthAccessToken", 'Int'>
    readonly scope: FieldRef<"OAuthAccessToken", 'String'>
    readonly expiresAt: FieldRef<"OAuthAccessToken", 'DateTime'>
    readonly createdAt: FieldRef<"OAuthAccessToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthAccessToken findUnique
   */
  export type OAuthAccessTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }

  /**
   * OAuthAccessToken findUniqueOrThrow
   */
  export type OAuthAccessTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }

  /**
   * OAuthAccessToken findFirst
   */
  export type OAuthAccessTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAccessTokens.
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAccessTokens.
     */
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }

  /**
   * OAuthAccessToken findFirstOrThrow
   */
  export type OAuthAccessTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAccessTokens.
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAccessTokens.
     */
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }

  /**
   * OAuthAccessToken findMany
   */
  export type OAuthAccessTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessTokens to fetch.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthAccessTokens.
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }

  /**
   * OAuthAccessToken create
   */
  export type OAuthAccessTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthAccessToken.
     */
    data: XOR<OAuthAccessTokenCreateInput, OAuthAccessTokenUncheckedCreateInput>
  }

  /**
   * OAuthAccessToken createMany
   */
  export type OAuthAccessTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthAccessTokens.
     */
    data: OAuthAccessTokenCreateManyInput | OAuthAccessTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthAccessToken update
   */
  export type OAuthAccessTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthAccessToken.
     */
    data: XOR<OAuthAccessTokenUpdateInput, OAuthAccessTokenUncheckedUpdateInput>
    /**
     * Choose, which OAuthAccessToken to update.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }

  /**
   * OAuthAccessToken updateMany
   */
  export type OAuthAccessTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthAccessTokens.
     */
    data: XOR<OAuthAccessTokenUpdateManyMutationInput, OAuthAccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which OAuthAccessTokens to update
     */
    where?: OAuthAccessTokenWhereInput
  }

  /**
   * OAuthAccessToken upsert
   */
  export type OAuthAccessTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthAccessToken to update in case it exists.
     */
    where: OAuthAccessTokenWhereUniqueInput
    /**
     * In case the OAuthAccessToken found by the `where` argument doesn't exist, create a new OAuthAccessToken with this data.
     */
    create: XOR<OAuthAccessTokenCreateInput, OAuthAccessTokenUncheckedCreateInput>
    /**
     * In case the OAuthAccessToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthAccessTokenUpdateInput, OAuthAccessTokenUncheckedUpdateInput>
  }

  /**
   * OAuthAccessToken delete
   */
  export type OAuthAccessTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter which OAuthAccessToken to delete.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }

  /**
   * OAuthAccessToken deleteMany
   */
  export type OAuthAccessTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAccessTokens to delete
     */
    where?: OAuthAccessTokenWhereInput
  }

  /**
   * OAuthAccessToken without action
   */
  export type OAuthAccessTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    id: number | null
    discountValue: number | null
    maxUses: number | null
    currentUses: number | null
    createdBy: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    id: number | null
    discountValue: number | null
    maxUses: number | null
    currentUses: number | null
    createdBy: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: number | null
    maxUses: number | null
    currentUses: number | null
    validFrom: Date | null
    validUntil: Date | null
    isActive: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: string | null
    discountValue: number | null
    maxUses: number | null
    currentUses: number | null
    validFrom: Date | null
    validUntil: Date | null
    isActive: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discountType: number
    discountValue: number
    maxUses: number
    currentUses: number
    validFrom: number
    validUntil: number
    isActive: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    id?: true
    discountValue?: true
    maxUses?: true
    currentUses?: true
    createdBy?: true
  }

  export type PromoCodeSumAggregateInputType = {
    id?: true
    discountValue?: true
    maxUses?: true
    currentUses?: true
    createdBy?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    maxUses?: true
    currentUses?: true
    validFrom?: true
    validUntil?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    maxUses?: true
    currentUses?: true
    validFrom?: true
    validUntil?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    maxUses?: true
    currentUses?: true
    validFrom?: true
    validUntil?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: number
    code: string
    description: string | null
    discountType: string
    discountValue: number
    maxUses: number | null
    currentUses: number
    validFrom: Date
    validUntil: Date | null
    isActive: boolean
    createdBy: number
    createdAt: Date
    updatedAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    maxUses?: boolean
    currentUses?: boolean
    validFrom?: boolean
    validUntil?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>


  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    maxUses?: boolean
    currentUses?: boolean
    validFrom?: boolean
    validUntil?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      description: string | null
      discountType: string
      discountValue: number
      maxUses: number | null
      currentUses: number
      validFrom: Date
      validUntil: Date | null
      isActive: boolean
      createdBy: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */ 
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'Int'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly description: FieldRef<"PromoCode", 'String'>
    readonly discountType: FieldRef<"PromoCode", 'String'>
    readonly discountValue: FieldRef<"PromoCode", 'Float'>
    readonly maxUses: FieldRef<"PromoCode", 'Int'>
    readonly currentUses: FieldRef<"PromoCode", 'Int'>
    readonly validFrom: FieldRef<"PromoCode", 'DateTime'>
    readonly validUntil: FieldRef<"PromoCode", 'DateTime'>
    readonly isActive: FieldRef<"PromoCode", 'Boolean'>
    readonly createdBy: FieldRef<"PromoCode", 'Int'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
    readonly updatedAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    category: string | null
    title: string | null
    message: string | null
    link: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    category: string | null
    title: string | null
    message: string | null
    link: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    category: number
    title: number
    message: number
    link: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    title?: true
    message?: true
    link?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    title?: true
    message?: true
    link?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    category?: true
    title?: true
    message?: true
    link?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    type: string
    category: string | null
    title: string
    message: string
    link: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      category: string | null
      title: string
      message: string
      link: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly category: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    phone: 'phone',
    paymentMethod: 'paymentMethod',
    paymentDetails: 'paymentDetails',
    recoveryEmail: 'recoveryEmail',
    recoveryPhone: 'recoveryPhone',
    recoveryPhoneCountryCode: 'recoveryPhoneCountryCode',
    allowEmailRecovery: 'allowEmailRecovery',
    allowPhoneRecovery: 'allowPhoneRecovery',
    allowQRLogin: 'allowQRLogin',
    recoveryPhrase: 'recoveryPhrase',
    allowRecoveryPhrase: 'allowRecoveryPhrase',
    allowDeviceRecovery: 'allowDeviceRecovery',
    recoveryFileHash: 'recoveryFileHash',
    preferences: 'preferences',
    credits: 'credits',
    appliedGiftCodes: 'appliedGiftCodes',
    twoPasswordMode: 'twoPasswordMode',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorMethod: 'twoFactorMethod',
    twoFactorSecret: 'twoFactorSecret',
    emergencyContacts: 'emergencyContacts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DomainScalarFieldEnum: {
    id: 'id',
    domainName: 'domainName',
    userId: 'userId',
    dnsVerified: 'dnsVerified',
    mxRecord: 'mxRecord',
    spfRecord: 'spfRecord',
    dkimRecord: 'dkimRecord',
    dmarcRecord: 'dmarcRecord',
    lastDnsCheck: 'lastDnsCheck',
    smtpProvider: 'smtpProvider',
    smtpHost: 'smtpHost',
    smtpPort: 'smtpPort',
    smtpUser: 'smtpUser',
    smtpPassword: 'smtpPassword',
    smtpApiKey: 'smtpApiKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


  export const EmailAccountScalarFieldEnum: {
    id: 'id',
    address: 'address',
    password: 'password',
    storageUsed: 'storageUsed',
    domainId: 'domainId',
    ownerId: 'ownerId',
    smtpHost: 'smtpHost',
    smtpPort: 'smtpPort',
    smtpUser: 'smtpUser',
    smtpPassword: 'smtpPassword',
    createdAt: 'createdAt'
  };

  export type EmailAccountScalarFieldEnum = (typeof EmailAccountScalarFieldEnum)[keyof typeof EmailAccountScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    emailAccountId: 'emailAccountId',
    from: 'from',
    to: 'to',
    subject: 'subject',
    body: 'body',
    htmlBody: 'htmlBody',
    isRead: 'isRead',
    isSent: 'isSent',
    messageId: 'messageId',
    inReplyTo: 'inReplyTo',
    references: 'references',
    priority: 'priority',
    receivedAt: 'receivedAt',
    sentAt: 'sentAt',
    isStarred: 'isStarred',
    isArchived: 'isArchived',
    isSpam: 'isSpam',
    isImportant: 'isImportant',
    isDraft: 'isDraft',
    isDeleted: 'isDeleted',
    folderId: 'folderId',
    labels: 'labels',
    scheduledFor: 'scheduledFor'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priceMonthly: 'priceMonthly',
    priceYearly: 'priceYearly',
    maxEmails: 'maxEmails',
    maxStorageGB: 'maxStorageGB',
    maxDomains: 'maxDomains',
    features: 'features',
    category: 'category',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    plan: 'plan',
    startDate: 'startDate',
    endDate: 'endDate',
    planId: 'planId'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subscriptionId: 'subscriptionId',
    createdAt: 'createdAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subject: 'subject',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketAttachmentScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    createdAt: 'createdAt'
  };

  export type TicketAttachmentScalarFieldEnum = (typeof TicketAttachmentScalarFieldEnum)[keyof typeof TicketAttachmentScalarFieldEnum]


  export const TicketMessageScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    userId: 'userId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type TicketMessageScalarFieldEnum = (typeof TicketMessageScalarFieldEnum)[keyof typeof TicketMessageScalarFieldEnum]


  export const EmailAttachmentScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    contentId: 'contentId',
    createdAt: 'createdAt'
  };

  export type EmailAttachmentScalarFieldEnum = (typeof EmailAttachmentScalarFieldEnum)[keyof typeof EmailAttachmentScalarFieldEnum]


  export const OAuthApplicationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    website: 'website',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    redirectUris: 'redirectUris',
    userId: 'userId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OAuthApplicationScalarFieldEnum = (typeof OAuthApplicationScalarFieldEnum)[keyof typeof OAuthApplicationScalarFieldEnum]


  export const OAuthAuthCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    applicationId: 'applicationId',
    userId: 'userId',
    redirectUri: 'redirectUri',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type OAuthAuthCodeScalarFieldEnum = (typeof OAuthAuthCodeScalarFieldEnum)[keyof typeof OAuthAuthCodeScalarFieldEnum]


  export const OAuthAccessTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    refreshToken: 'refreshToken',
    applicationId: 'applicationId',
    userId: 'userId',
    scope: 'scope',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OAuthAccessTokenScalarFieldEnum = (typeof OAuthAccessTokenScalarFieldEnum)[keyof typeof OAuthAccessTokenScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    maxUses: 'maxUses',
    currentUses: 'currentUses',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    category: 'category',
    title: 'title',
    message: 'message',
    link: 'link',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    paymentMethod?: StringNullableFilter<"User"> | string | null
    paymentDetails?: StringNullableFilter<"User"> | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryPhone?: StringNullableFilter<"User"> | string | null
    recoveryPhoneCountryCode?: StringNullableFilter<"User"> | string | null
    allowEmailRecovery?: BoolFilter<"User"> | boolean
    allowPhoneRecovery?: BoolFilter<"User"> | boolean
    allowQRLogin?: BoolFilter<"User"> | boolean
    recoveryPhrase?: StringNullableFilter<"User"> | string | null
    allowRecoveryPhrase?: BoolFilter<"User"> | boolean
    allowDeviceRecovery?: BoolFilter<"User"> | boolean
    recoveryFileHash?: StringNullableFilter<"User"> | string | null
    preferences?: StringNullableFilter<"User"> | string | null
    credits?: FloatFilter<"User"> | number
    appliedGiftCodes?: StringNullableFilter<"User"> | string | null
    twoPasswordMode?: BoolFilter<"User"> | boolean
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    emergencyContacts?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    Domain?: DomainListRelationFilter
    EmailAccounts?: EmailAccountListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    invoices?: InvoiceListRelationFilter
    tickets?: TicketListRelationFilter
    ticketMessages?: TicketMessageListRelationFilter
    oauthApplications?: OAuthApplicationListRelationFilter
    oauthAuthCodes?: OAuthAuthCodeListRelationFilter
    oauthAccessTokens?: OAuthAccessTokenListRelationFilter
    createdPromoCodes?: PromoCodeListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryPhone?: SortOrderInput | SortOrder
    recoveryPhoneCountryCode?: SortOrderInput | SortOrder
    allowEmailRecovery?: SortOrder
    allowPhoneRecovery?: SortOrder
    allowQRLogin?: SortOrder
    recoveryPhrase?: SortOrderInput | SortOrder
    allowRecoveryPhrase?: SortOrder
    allowDeviceRecovery?: SortOrder
    recoveryFileHash?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    credits?: SortOrder
    appliedGiftCodes?: SortOrderInput | SortOrder
    twoPasswordMode?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    emergencyContacts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Domain?: DomainOrderByRelationAggregateInput
    EmailAccounts?: EmailAccountOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    ticketMessages?: TicketMessageOrderByRelationAggregateInput
    oauthApplications?: OAuthApplicationOrderByRelationAggregateInput
    oauthAuthCodes?: OAuthAuthCodeOrderByRelationAggregateInput
    oauthAccessTokens?: OAuthAccessTokenOrderByRelationAggregateInput
    createdPromoCodes?: PromoCodeOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    paymentMethod?: StringNullableFilter<"User"> | string | null
    paymentDetails?: StringNullableFilter<"User"> | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    recoveryPhone?: StringNullableFilter<"User"> | string | null
    recoveryPhoneCountryCode?: StringNullableFilter<"User"> | string | null
    allowEmailRecovery?: BoolFilter<"User"> | boolean
    allowPhoneRecovery?: BoolFilter<"User"> | boolean
    allowQRLogin?: BoolFilter<"User"> | boolean
    recoveryPhrase?: StringNullableFilter<"User"> | string | null
    allowRecoveryPhrase?: BoolFilter<"User"> | boolean
    allowDeviceRecovery?: BoolFilter<"User"> | boolean
    recoveryFileHash?: StringNullableFilter<"User"> | string | null
    preferences?: StringNullableFilter<"User"> | string | null
    credits?: FloatFilter<"User"> | number
    appliedGiftCodes?: StringNullableFilter<"User"> | string | null
    twoPasswordMode?: BoolFilter<"User"> | boolean
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    emergencyContacts?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    Domain?: DomainListRelationFilter
    EmailAccounts?: EmailAccountListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    invoices?: InvoiceListRelationFilter
    tickets?: TicketListRelationFilter
    ticketMessages?: TicketMessageListRelationFilter
    oauthApplications?: OAuthApplicationListRelationFilter
    oauthAuthCodes?: OAuthAuthCodeListRelationFilter
    oauthAccessTokens?: OAuthAccessTokenListRelationFilter
    createdPromoCodes?: PromoCodeListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    recoveryPhone?: SortOrderInput | SortOrder
    recoveryPhoneCountryCode?: SortOrderInput | SortOrder
    allowEmailRecovery?: SortOrder
    allowPhoneRecovery?: SortOrder
    allowQRLogin?: SortOrder
    recoveryPhrase?: SortOrderInput | SortOrder
    allowRecoveryPhrase?: SortOrder
    allowDeviceRecovery?: SortOrder
    recoveryFileHash?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    credits?: SortOrder
    appliedGiftCodes?: SortOrderInput | SortOrder
    twoPasswordMode?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    emergencyContacts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"User"> | string | null
    paymentDetails?: StringNullableWithAggregatesFilter<"User"> | string | null
    recoveryEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    recoveryPhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    recoveryPhoneCountryCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    allowEmailRecovery?: BoolWithAggregatesFilter<"User"> | boolean
    allowPhoneRecovery?: BoolWithAggregatesFilter<"User"> | boolean
    allowQRLogin?: BoolWithAggregatesFilter<"User"> | boolean
    recoveryPhrase?: StringNullableWithAggregatesFilter<"User"> | string | null
    allowRecoveryPhrase?: BoolWithAggregatesFilter<"User"> | boolean
    allowDeviceRecovery?: BoolWithAggregatesFilter<"User"> | boolean
    recoveryFileHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferences?: StringNullableWithAggregatesFilter<"User"> | string | null
    credits?: FloatWithAggregatesFilter<"User"> | number
    appliedGiftCodes?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoPasswordMode?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorMethod?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyContacts?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type DomainWhereInput = {
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    id?: IntFilter<"Domain"> | number
    domainName?: StringFilter<"Domain"> | string
    userId?: IntFilter<"Domain"> | number
    dnsVerified?: BoolFilter<"Domain"> | boolean
    mxRecord?: StringNullableFilter<"Domain"> | string | null
    spfRecord?: StringNullableFilter<"Domain"> | string | null
    dkimRecord?: StringNullableFilter<"Domain"> | string | null
    dmarcRecord?: StringNullableFilter<"Domain"> | string | null
    lastDnsCheck?: DateTimeNullableFilter<"Domain"> | Date | string | null
    smtpProvider?: StringNullableFilter<"Domain"> | string | null
    smtpHost?: StringNullableFilter<"Domain"> | string | null
    smtpPort?: IntNullableFilter<"Domain"> | number | null
    smtpUser?: StringNullableFilter<"Domain"> | string | null
    smtpPassword?: StringNullableFilter<"Domain"> | string | null
    smtpApiKey?: StringNullableFilter<"Domain"> | string | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Domain"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    emailAccounts?: EmailAccountListRelationFilter
  }

  export type DomainOrderByWithRelationInput = {
    id?: SortOrder
    domainName?: SortOrder
    userId?: SortOrder
    dnsVerified?: SortOrder
    mxRecord?: SortOrderInput | SortOrder
    spfRecord?: SortOrderInput | SortOrder
    dkimRecord?: SortOrderInput | SortOrder
    dmarcRecord?: SortOrderInput | SortOrder
    lastDnsCheck?: SortOrderInput | SortOrder
    smtpProvider?: SortOrderInput | SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    smtpApiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    emailAccounts?: EmailAccountOrderByRelationAggregateInput
  }

  export type DomainWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    domainName?: string
    AND?: DomainWhereInput | DomainWhereInput[]
    OR?: DomainWhereInput[]
    NOT?: DomainWhereInput | DomainWhereInput[]
    userId?: IntFilter<"Domain"> | number
    dnsVerified?: BoolFilter<"Domain"> | boolean
    mxRecord?: StringNullableFilter<"Domain"> | string | null
    spfRecord?: StringNullableFilter<"Domain"> | string | null
    dkimRecord?: StringNullableFilter<"Domain"> | string | null
    dmarcRecord?: StringNullableFilter<"Domain"> | string | null
    lastDnsCheck?: DateTimeNullableFilter<"Domain"> | Date | string | null
    smtpProvider?: StringNullableFilter<"Domain"> | string | null
    smtpHost?: StringNullableFilter<"Domain"> | string | null
    smtpPort?: IntNullableFilter<"Domain"> | number | null
    smtpUser?: StringNullableFilter<"Domain"> | string | null
    smtpPassword?: StringNullableFilter<"Domain"> | string | null
    smtpApiKey?: StringNullableFilter<"Domain"> | string | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Domain"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    emailAccounts?: EmailAccountListRelationFilter
  }, "id" | "domainName">

  export type DomainOrderByWithAggregationInput = {
    id?: SortOrder
    domainName?: SortOrder
    userId?: SortOrder
    dnsVerified?: SortOrder
    mxRecord?: SortOrderInput | SortOrder
    spfRecord?: SortOrderInput | SortOrder
    dkimRecord?: SortOrderInput | SortOrder
    dmarcRecord?: SortOrderInput | SortOrder
    lastDnsCheck?: SortOrderInput | SortOrder
    smtpProvider?: SortOrderInput | SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    smtpApiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: DomainCountOrderByAggregateInput
    _avg?: DomainAvgOrderByAggregateInput
    _max?: DomainMaxOrderByAggregateInput
    _min?: DomainMinOrderByAggregateInput
    _sum?: DomainSumOrderByAggregateInput
  }

  export type DomainScalarWhereWithAggregatesInput = {
    AND?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    OR?: DomainScalarWhereWithAggregatesInput[]
    NOT?: DomainScalarWhereWithAggregatesInput | DomainScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Domain"> | number
    domainName?: StringWithAggregatesFilter<"Domain"> | string
    userId?: IntWithAggregatesFilter<"Domain"> | number
    dnsVerified?: BoolWithAggregatesFilter<"Domain"> | boolean
    mxRecord?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    spfRecord?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    dkimRecord?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    dmarcRecord?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    lastDnsCheck?: DateTimeNullableWithAggregatesFilter<"Domain"> | Date | string | null
    smtpProvider?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    smtpHost?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    smtpPort?: IntNullableWithAggregatesFilter<"Domain"> | number | null
    smtpUser?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    smtpPassword?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    smtpApiKey?: StringNullableWithAggregatesFilter<"Domain"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Domain"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Domain"> | Date | string | null
  }

  export type EmailAccountWhereInput = {
    AND?: EmailAccountWhereInput | EmailAccountWhereInput[]
    OR?: EmailAccountWhereInput[]
    NOT?: EmailAccountWhereInput | EmailAccountWhereInput[]
    id?: IntFilter<"EmailAccount"> | number
    address?: StringFilter<"EmailAccount"> | string
    password?: StringFilter<"EmailAccount"> | string
    storageUsed?: FloatFilter<"EmailAccount"> | number
    domainId?: IntFilter<"EmailAccount"> | number
    ownerId?: IntNullableFilter<"EmailAccount"> | number | null
    smtpHost?: StringNullableFilter<"EmailAccount"> | string | null
    smtpPort?: IntNullableFilter<"EmailAccount"> | number | null
    smtpUser?: StringNullableFilter<"EmailAccount"> | string | null
    smtpPassword?: StringNullableFilter<"EmailAccount"> | string | null
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
    domain?: XOR<DomainRelationFilter, DomainWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    emails?: EmailListRelationFilter
  }

  export type EmailAccountOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    password?: SortOrder
    storageUsed?: SortOrder
    domainId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domain?: DomainOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    emails?: EmailOrderByRelationAggregateInput
  }

  export type EmailAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    address?: string
    AND?: EmailAccountWhereInput | EmailAccountWhereInput[]
    OR?: EmailAccountWhereInput[]
    NOT?: EmailAccountWhereInput | EmailAccountWhereInput[]
    password?: StringFilter<"EmailAccount"> | string
    storageUsed?: FloatFilter<"EmailAccount"> | number
    domainId?: IntFilter<"EmailAccount"> | number
    ownerId?: IntNullableFilter<"EmailAccount"> | number | null
    smtpHost?: StringNullableFilter<"EmailAccount"> | string | null
    smtpPort?: IntNullableFilter<"EmailAccount"> | number | null
    smtpUser?: StringNullableFilter<"EmailAccount"> | string | null
    smtpPassword?: StringNullableFilter<"EmailAccount"> | string | null
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
    domain?: XOR<DomainRelationFilter, DomainWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    emails?: EmailListRelationFilter
  }, "id" | "address">

  export type EmailAccountOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    password?: SortOrder
    storageUsed?: SortOrder
    domainId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailAccountCountOrderByAggregateInput
    _avg?: EmailAccountAvgOrderByAggregateInput
    _max?: EmailAccountMaxOrderByAggregateInput
    _min?: EmailAccountMinOrderByAggregateInput
    _sum?: EmailAccountSumOrderByAggregateInput
  }

  export type EmailAccountScalarWhereWithAggregatesInput = {
    AND?: EmailAccountScalarWhereWithAggregatesInput | EmailAccountScalarWhereWithAggregatesInput[]
    OR?: EmailAccountScalarWhereWithAggregatesInput[]
    NOT?: EmailAccountScalarWhereWithAggregatesInput | EmailAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailAccount"> | number
    address?: StringWithAggregatesFilter<"EmailAccount"> | string
    password?: StringWithAggregatesFilter<"EmailAccount"> | string
    storageUsed?: FloatWithAggregatesFilter<"EmailAccount"> | number
    domainId?: IntWithAggregatesFilter<"EmailAccount"> | number
    ownerId?: IntNullableWithAggregatesFilter<"EmailAccount"> | number | null
    smtpHost?: StringNullableWithAggregatesFilter<"EmailAccount"> | string | null
    smtpPort?: IntNullableWithAggregatesFilter<"EmailAccount"> | number | null
    smtpUser?: StringNullableWithAggregatesFilter<"EmailAccount"> | string | null
    smtpPassword?: StringNullableWithAggregatesFilter<"EmailAccount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailAccount"> | Date | string
  }

  export type EmailWhereInput = {
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    id?: IntFilter<"Email"> | number
    emailAccountId?: IntFilter<"Email"> | number
    from?: StringFilter<"Email"> | string
    to?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    body?: StringFilter<"Email"> | string
    htmlBody?: StringNullableFilter<"Email"> | string | null
    isRead?: BoolFilter<"Email"> | boolean
    isSent?: BoolFilter<"Email"> | boolean
    messageId?: StringNullableFilter<"Email"> | string | null
    inReplyTo?: StringNullableFilter<"Email"> | string | null
    references?: StringNullableFilter<"Email"> | string | null
    priority?: StringNullableFilter<"Email"> | string | null
    receivedAt?: DateTimeFilter<"Email"> | Date | string
    sentAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    isStarred?: BoolFilter<"Email"> | boolean
    isArchived?: BoolFilter<"Email"> | boolean
    isSpam?: BoolFilter<"Email"> | boolean
    isImportant?: BoolFilter<"Email"> | boolean
    isDraft?: BoolFilter<"Email"> | boolean
    isDeleted?: BoolFilter<"Email"> | boolean
    folderId?: IntNullableFilter<"Email"> | number | null
    labels?: StringNullableFilter<"Email"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Email"> | Date | string | null
    account?: XOR<EmailAccountRelationFilter, EmailAccountWhereInput>
    attachments?: EmailAttachmentListRelationFilter
  }

  export type EmailOrderByWithRelationInput = {
    id?: SortOrder
    emailAccountId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    htmlBody?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isSent?: SortOrder
    messageId?: SortOrderInput | SortOrder
    inReplyTo?: SortOrderInput | SortOrder
    references?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    isStarred?: SortOrder
    isArchived?: SortOrder
    isSpam?: SortOrder
    isImportant?: SortOrder
    isDraft?: SortOrder
    isDeleted?: SortOrder
    folderId?: SortOrderInput | SortOrder
    labels?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    account?: EmailAccountOrderByWithRelationInput
    attachments?: EmailAttachmentOrderByRelationAggregateInput
  }

  export type EmailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    messageId?: string
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    emailAccountId?: IntFilter<"Email"> | number
    from?: StringFilter<"Email"> | string
    to?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    body?: StringFilter<"Email"> | string
    htmlBody?: StringNullableFilter<"Email"> | string | null
    isRead?: BoolFilter<"Email"> | boolean
    isSent?: BoolFilter<"Email"> | boolean
    inReplyTo?: StringNullableFilter<"Email"> | string | null
    references?: StringNullableFilter<"Email"> | string | null
    priority?: StringNullableFilter<"Email"> | string | null
    receivedAt?: DateTimeFilter<"Email"> | Date | string
    sentAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    isStarred?: BoolFilter<"Email"> | boolean
    isArchived?: BoolFilter<"Email"> | boolean
    isSpam?: BoolFilter<"Email"> | boolean
    isImportant?: BoolFilter<"Email"> | boolean
    isDraft?: BoolFilter<"Email"> | boolean
    isDeleted?: BoolFilter<"Email"> | boolean
    folderId?: IntNullableFilter<"Email"> | number | null
    labels?: StringNullableFilter<"Email"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Email"> | Date | string | null
    account?: XOR<EmailAccountRelationFilter, EmailAccountWhereInput>
    attachments?: EmailAttachmentListRelationFilter
  }, "id" | "messageId">

  export type EmailOrderByWithAggregationInput = {
    id?: SortOrder
    emailAccountId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    htmlBody?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isSent?: SortOrder
    messageId?: SortOrderInput | SortOrder
    inReplyTo?: SortOrderInput | SortOrder
    references?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    isStarred?: SortOrder
    isArchived?: SortOrder
    isSpam?: SortOrder
    isImportant?: SortOrder
    isDraft?: SortOrder
    isDeleted?: SortOrder
    folderId?: SortOrderInput | SortOrder
    labels?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    _count?: EmailCountOrderByAggregateInput
    _avg?: EmailAvgOrderByAggregateInput
    _max?: EmailMaxOrderByAggregateInput
    _min?: EmailMinOrderByAggregateInput
    _sum?: EmailSumOrderByAggregateInput
  }

  export type EmailScalarWhereWithAggregatesInput = {
    AND?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    OR?: EmailScalarWhereWithAggregatesInput[]
    NOT?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Email"> | number
    emailAccountId?: IntWithAggregatesFilter<"Email"> | number
    from?: StringWithAggregatesFilter<"Email"> | string
    to?: StringWithAggregatesFilter<"Email"> | string
    subject?: StringWithAggregatesFilter<"Email"> | string
    body?: StringWithAggregatesFilter<"Email"> | string
    htmlBody?: StringNullableWithAggregatesFilter<"Email"> | string | null
    isRead?: BoolWithAggregatesFilter<"Email"> | boolean
    isSent?: BoolWithAggregatesFilter<"Email"> | boolean
    messageId?: StringNullableWithAggregatesFilter<"Email"> | string | null
    inReplyTo?: StringNullableWithAggregatesFilter<"Email"> | string | null
    references?: StringNullableWithAggregatesFilter<"Email"> | string | null
    priority?: StringNullableWithAggregatesFilter<"Email"> | string | null
    receivedAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
    isStarred?: BoolWithAggregatesFilter<"Email"> | boolean
    isArchived?: BoolWithAggregatesFilter<"Email"> | boolean
    isSpam?: BoolWithAggregatesFilter<"Email"> | boolean
    isImportant?: BoolWithAggregatesFilter<"Email"> | boolean
    isDraft?: BoolWithAggregatesFilter<"Email"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Email"> | boolean
    folderId?: IntNullableWithAggregatesFilter<"Email"> | number | null
    labels?: StringNullableWithAggregatesFilter<"Email"> | string | null
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: IntFilter<"Plan"> | number
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    priceMonthly?: FloatFilter<"Plan"> | number
    priceYearly?: FloatFilter<"Plan"> | number
    maxEmails?: IntFilter<"Plan"> | number
    maxStorageGB?: IntFilter<"Plan"> | number
    maxDomains?: IntFilter<"Plan"> | number
    features?: StringNullableFilter<"Plan"> | string | null
    category?: StringFilter<"Plan"> | string
    isActive?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxEmails?: SortOrder
    maxStorageGB?: SortOrder
    maxDomains?: SortOrder
    features?: SortOrderInput | SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    priceMonthly?: FloatFilter<"Plan"> | number
    priceYearly?: FloatFilter<"Plan"> | number
    maxEmails?: IntFilter<"Plan"> | number
    maxStorageGB?: IntFilter<"Plan"> | number
    maxDomains?: IntFilter<"Plan"> | number
    features?: StringNullableFilter<"Plan"> | string | null
    category?: StringFilter<"Plan"> | string
    isActive?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxEmails?: SortOrder
    maxStorageGB?: SortOrder
    maxDomains?: SortOrder
    features?: SortOrderInput | SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Plan"> | number
    name?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    priceMonthly?: FloatWithAggregatesFilter<"Plan"> | number
    priceYearly?: FloatWithAggregatesFilter<"Plan"> | number
    maxEmails?: IntWithAggregatesFilter<"Plan"> | number
    maxStorageGB?: IntWithAggregatesFilter<"Plan"> | number
    maxDomains?: IntWithAggregatesFilter<"Plan"> | number
    features?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    category?: StringWithAggregatesFilter<"Plan"> | string
    isActive?: BoolWithAggregatesFilter<"Plan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    userId?: IntFilter<"Subscription"> | number
    plan?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    planId?: IntNullableFilter<"Subscription"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
    Plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    Plan?: PlanOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: IntFilter<"Subscription"> | number
    plan?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    planId?: IntNullableFilter<"Subscription"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
    Plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    userId?: IntWithAggregatesFilter<"Subscription"> | number
    plan?: StringWithAggregatesFilter<"Subscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    planId?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    userId?: IntFilter<"Invoice"> | number
    subscriptionId?: IntNullableFilter<"Invoice"> | number | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: IntFilter<"Invoice"> | number
    subscriptionId?: IntNullableFilter<"Invoice"> | number | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    userId?: IntWithAggregatesFilter<"Invoice"> | number
    subscriptionId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: IntFilter<"Ticket"> | number
    userId?: IntFilter<"Ticket"> | number
    subject?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    priority?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: TicketAttachmentListRelationFilter
    messages?: TicketMessageListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    attachments?: TicketAttachmentOrderByRelationAggregateInput
    messages?: TicketMessageOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    userId?: IntFilter<"Ticket"> | number
    subject?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    priority?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: TicketAttachmentListRelationFilter
    messages?: TicketMessageListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ticket"> | number
    userId?: IntWithAggregatesFilter<"Ticket"> | number
    subject?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    status?: StringWithAggregatesFilter<"Ticket"> | string
    priority?: StringWithAggregatesFilter<"Ticket"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type TicketAttachmentWhereInput = {
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    id?: IntFilter<"TicketAttachment"> | number
    ticketId?: IntFilter<"TicketAttachment"> | number
    fileName?: StringFilter<"TicketAttachment"> | string
    filePath?: StringFilter<"TicketAttachment"> | string
    fileSize?: IntFilter<"TicketAttachment"> | number
    mimeType?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }

  export type TicketAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    ticketId?: IntFilter<"TicketAttachment"> | number
    fileName?: StringFilter<"TicketAttachment"> | string
    filePath?: StringFilter<"TicketAttachment"> | string
    fileSize?: IntFilter<"TicketAttachment"> | number
    mimeType?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    _count?: TicketAttachmentCountOrderByAggregateInput
    _avg?: TicketAttachmentAvgOrderByAggregateInput
    _max?: TicketAttachmentMaxOrderByAggregateInput
    _min?: TicketAttachmentMinOrderByAggregateInput
    _sum?: TicketAttachmentSumOrderByAggregateInput
  }

  export type TicketAttachmentScalarWhereWithAggregatesInput = {
    AND?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    OR?: TicketAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketAttachment"> | number
    ticketId?: IntWithAggregatesFilter<"TicketAttachment"> | number
    fileName?: StringWithAggregatesFilter<"TicketAttachment"> | string
    filePath?: StringWithAggregatesFilter<"TicketAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"TicketAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"TicketAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketAttachment"> | Date | string
  }

  export type TicketMessageWhereInput = {
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    id?: IntFilter<"TicketMessage"> | number
    ticketId?: IntFilter<"TicketMessage"> | number
    userId?: IntFilter<"TicketMessage"> | number
    message?: StringFilter<"TicketMessage"> | string
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TicketMessageOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TicketMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    ticketId?: IntFilter<"TicketMessage"> | number
    userId?: IntFilter<"TicketMessage"> | number
    message?: StringFilter<"TicketMessage"> | string
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TicketMessageOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: TicketMessageCountOrderByAggregateInput
    _avg?: TicketMessageAvgOrderByAggregateInput
    _max?: TicketMessageMaxOrderByAggregateInput
    _min?: TicketMessageMinOrderByAggregateInput
    _sum?: TicketMessageSumOrderByAggregateInput
  }

  export type TicketMessageScalarWhereWithAggregatesInput = {
    AND?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    OR?: TicketMessageScalarWhereWithAggregatesInput[]
    NOT?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketMessage"> | number
    ticketId?: IntWithAggregatesFilter<"TicketMessage"> | number
    userId?: IntWithAggregatesFilter<"TicketMessage"> | number
    message?: StringWithAggregatesFilter<"TicketMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketMessage"> | Date | string
  }

  export type EmailAttachmentWhereInput = {
    AND?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    OR?: EmailAttachmentWhereInput[]
    NOT?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    id?: IntFilter<"EmailAttachment"> | number
    emailId?: IntFilter<"EmailAttachment"> | number
    fileName?: StringFilter<"EmailAttachment"> | string
    filePath?: StringFilter<"EmailAttachment"> | string
    fileSize?: IntFilter<"EmailAttachment"> | number
    mimeType?: StringFilter<"EmailAttachment"> | string
    contentId?: StringNullableFilter<"EmailAttachment"> | string | null
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
    email?: XOR<EmailRelationFilter, EmailWhereInput>
  }

  export type EmailAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    contentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type EmailAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    OR?: EmailAttachmentWhereInput[]
    NOT?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    emailId?: IntFilter<"EmailAttachment"> | number
    fileName?: StringFilter<"EmailAttachment"> | string
    filePath?: StringFilter<"EmailAttachment"> | string
    fileSize?: IntFilter<"EmailAttachment"> | number
    mimeType?: StringFilter<"EmailAttachment"> | string
    contentId?: StringNullableFilter<"EmailAttachment"> | string | null
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
    email?: XOR<EmailRelationFilter, EmailWhereInput>
  }, "id">

  export type EmailAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    contentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailAttachmentCountOrderByAggregateInput
    _avg?: EmailAttachmentAvgOrderByAggregateInput
    _max?: EmailAttachmentMaxOrderByAggregateInput
    _min?: EmailAttachmentMinOrderByAggregateInput
    _sum?: EmailAttachmentSumOrderByAggregateInput
  }

  export type EmailAttachmentScalarWhereWithAggregatesInput = {
    AND?: EmailAttachmentScalarWhereWithAggregatesInput | EmailAttachmentScalarWhereWithAggregatesInput[]
    OR?: EmailAttachmentScalarWhereWithAggregatesInput[]
    NOT?: EmailAttachmentScalarWhereWithAggregatesInput | EmailAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailAttachment"> | number
    emailId?: IntWithAggregatesFilter<"EmailAttachment"> | number
    fileName?: StringWithAggregatesFilter<"EmailAttachment"> | string
    filePath?: StringWithAggregatesFilter<"EmailAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"EmailAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"EmailAttachment"> | string
    contentId?: StringNullableWithAggregatesFilter<"EmailAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailAttachment"> | Date | string
  }

  export type OAuthApplicationWhereInput = {
    AND?: OAuthApplicationWhereInput | OAuthApplicationWhereInput[]
    OR?: OAuthApplicationWhereInput[]
    NOT?: OAuthApplicationWhereInput | OAuthApplicationWhereInput[]
    id?: IntFilter<"OAuthApplication"> | number
    name?: StringFilter<"OAuthApplication"> | string
    description?: StringNullableFilter<"OAuthApplication"> | string | null
    website?: StringNullableFilter<"OAuthApplication"> | string | null
    clientId?: StringFilter<"OAuthApplication"> | string
    clientSecret?: StringFilter<"OAuthApplication"> | string
    redirectUris?: StringFilter<"OAuthApplication"> | string
    userId?: IntFilter<"OAuthApplication"> | number
    isActive?: BoolFilter<"OAuthApplication"> | boolean
    createdAt?: DateTimeFilter<"OAuthApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthApplication"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    authCodes?: OAuthAuthCodeListRelationFilter
    accessTokens?: OAuthAccessTokenListRelationFilter
  }

  export type OAuthApplicationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    authCodes?: OAuthAuthCodeOrderByRelationAggregateInput
    accessTokens?: OAuthAccessTokenOrderByRelationAggregateInput
  }

  export type OAuthApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientId?: string
    AND?: OAuthApplicationWhereInput | OAuthApplicationWhereInput[]
    OR?: OAuthApplicationWhereInput[]
    NOT?: OAuthApplicationWhereInput | OAuthApplicationWhereInput[]
    name?: StringFilter<"OAuthApplication"> | string
    description?: StringNullableFilter<"OAuthApplication"> | string | null
    website?: StringNullableFilter<"OAuthApplication"> | string | null
    clientSecret?: StringFilter<"OAuthApplication"> | string
    redirectUris?: StringFilter<"OAuthApplication"> | string
    userId?: IntFilter<"OAuthApplication"> | number
    isActive?: BoolFilter<"OAuthApplication"> | boolean
    createdAt?: DateTimeFilter<"OAuthApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthApplication"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    authCodes?: OAuthAuthCodeListRelationFilter
    accessTokens?: OAuthAccessTokenListRelationFilter
  }, "id" | "clientId">

  export type OAuthApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OAuthApplicationCountOrderByAggregateInput
    _avg?: OAuthApplicationAvgOrderByAggregateInput
    _max?: OAuthApplicationMaxOrderByAggregateInput
    _min?: OAuthApplicationMinOrderByAggregateInput
    _sum?: OAuthApplicationSumOrderByAggregateInput
  }

  export type OAuthApplicationScalarWhereWithAggregatesInput = {
    AND?: OAuthApplicationScalarWhereWithAggregatesInput | OAuthApplicationScalarWhereWithAggregatesInput[]
    OR?: OAuthApplicationScalarWhereWithAggregatesInput[]
    NOT?: OAuthApplicationScalarWhereWithAggregatesInput | OAuthApplicationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OAuthApplication"> | number
    name?: StringWithAggregatesFilter<"OAuthApplication"> | string
    description?: StringNullableWithAggregatesFilter<"OAuthApplication"> | string | null
    website?: StringNullableWithAggregatesFilter<"OAuthApplication"> | string | null
    clientId?: StringWithAggregatesFilter<"OAuthApplication"> | string
    clientSecret?: StringWithAggregatesFilter<"OAuthApplication"> | string
    redirectUris?: StringWithAggregatesFilter<"OAuthApplication"> | string
    userId?: IntWithAggregatesFilter<"OAuthApplication"> | number
    isActive?: BoolWithAggregatesFilter<"OAuthApplication"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OAuthApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OAuthApplication"> | Date | string
  }

  export type OAuthAuthCodeWhereInput = {
    AND?: OAuthAuthCodeWhereInput | OAuthAuthCodeWhereInput[]
    OR?: OAuthAuthCodeWhereInput[]
    NOT?: OAuthAuthCodeWhereInput | OAuthAuthCodeWhereInput[]
    id?: IntFilter<"OAuthAuthCode"> | number
    code?: StringFilter<"OAuthAuthCode"> | string
    applicationId?: IntFilter<"OAuthAuthCode"> | number
    userId?: IntFilter<"OAuthAuthCode"> | number
    redirectUri?: StringFilter<"OAuthAuthCode"> | string
    expiresAt?: DateTimeFilter<"OAuthAuthCode"> | Date | string
    used?: BoolFilter<"OAuthAuthCode"> | boolean
    createdAt?: DateTimeFilter<"OAuthAuthCode"> | Date | string
    application?: XOR<OAuthApplicationRelationFilter, OAuthApplicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OAuthAuthCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    application?: OAuthApplicationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OAuthAuthCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: OAuthAuthCodeWhereInput | OAuthAuthCodeWhereInput[]
    OR?: OAuthAuthCodeWhereInput[]
    NOT?: OAuthAuthCodeWhereInput | OAuthAuthCodeWhereInput[]
    applicationId?: IntFilter<"OAuthAuthCode"> | number
    userId?: IntFilter<"OAuthAuthCode"> | number
    redirectUri?: StringFilter<"OAuthAuthCode"> | string
    expiresAt?: DateTimeFilter<"OAuthAuthCode"> | Date | string
    used?: BoolFilter<"OAuthAuthCode"> | boolean
    createdAt?: DateTimeFilter<"OAuthAuthCode"> | Date | string
    application?: XOR<OAuthApplicationRelationFilter, OAuthApplicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type OAuthAuthCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: OAuthAuthCodeCountOrderByAggregateInput
    _avg?: OAuthAuthCodeAvgOrderByAggregateInput
    _max?: OAuthAuthCodeMaxOrderByAggregateInput
    _min?: OAuthAuthCodeMinOrderByAggregateInput
    _sum?: OAuthAuthCodeSumOrderByAggregateInput
  }

  export type OAuthAuthCodeScalarWhereWithAggregatesInput = {
    AND?: OAuthAuthCodeScalarWhereWithAggregatesInput | OAuthAuthCodeScalarWhereWithAggregatesInput[]
    OR?: OAuthAuthCodeScalarWhereWithAggregatesInput[]
    NOT?: OAuthAuthCodeScalarWhereWithAggregatesInput | OAuthAuthCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OAuthAuthCode"> | number
    code?: StringWithAggregatesFilter<"OAuthAuthCode"> | string
    applicationId?: IntWithAggregatesFilter<"OAuthAuthCode"> | number
    userId?: IntWithAggregatesFilter<"OAuthAuthCode"> | number
    redirectUri?: StringWithAggregatesFilter<"OAuthAuthCode"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthAuthCode"> | Date | string
    used?: BoolWithAggregatesFilter<"OAuthAuthCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OAuthAuthCode"> | Date | string
  }

  export type OAuthAccessTokenWhereInput = {
    AND?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    OR?: OAuthAccessTokenWhereInput[]
    NOT?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    id?: IntFilter<"OAuthAccessToken"> | number
    token?: StringFilter<"OAuthAccessToken"> | string
    refreshToken?: StringNullableFilter<"OAuthAccessToken"> | string | null
    applicationId?: IntFilter<"OAuthAccessToken"> | number
    userId?: IntFilter<"OAuthAccessToken"> | number
    scope?: StringNullableFilter<"OAuthAccessToken"> | string | null
    expiresAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    application?: XOR<OAuthApplicationRelationFilter, OAuthApplicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OAuthAccessTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    scope?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    application?: OAuthApplicationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OAuthAccessTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    refreshToken?: string
    AND?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    OR?: OAuthAccessTokenWhereInput[]
    NOT?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    applicationId?: IntFilter<"OAuthAccessToken"> | number
    userId?: IntFilter<"OAuthAccessToken"> | number
    scope?: StringNullableFilter<"OAuthAccessToken"> | string | null
    expiresAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    application?: XOR<OAuthApplicationRelationFilter, OAuthApplicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token" | "refreshToken">

  export type OAuthAccessTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    scope?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: OAuthAccessTokenCountOrderByAggregateInput
    _avg?: OAuthAccessTokenAvgOrderByAggregateInput
    _max?: OAuthAccessTokenMaxOrderByAggregateInput
    _min?: OAuthAccessTokenMinOrderByAggregateInput
    _sum?: OAuthAccessTokenSumOrderByAggregateInput
  }

  export type OAuthAccessTokenScalarWhereWithAggregatesInput = {
    AND?: OAuthAccessTokenScalarWhereWithAggregatesInput | OAuthAccessTokenScalarWhereWithAggregatesInput[]
    OR?: OAuthAccessTokenScalarWhereWithAggregatesInput[]
    NOT?: OAuthAccessTokenScalarWhereWithAggregatesInput | OAuthAccessTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OAuthAccessToken"> | number
    token?: StringWithAggregatesFilter<"OAuthAccessToken"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"OAuthAccessToken"> | string | null
    applicationId?: IntWithAggregatesFilter<"OAuthAccessToken"> | number
    userId?: IntWithAggregatesFilter<"OAuthAccessToken"> | number
    scope?: StringNullableWithAggregatesFilter<"OAuthAccessToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OAuthAccessToken"> | Date | string
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: IntFilter<"PromoCode"> | number
    code?: StringFilter<"PromoCode"> | string
    description?: StringNullableFilter<"PromoCode"> | string | null
    discountType?: StringFilter<"PromoCode"> | string
    discountValue?: FloatFilter<"PromoCode"> | number
    maxUses?: IntNullableFilter<"PromoCode"> | number | null
    currentUses?: IntFilter<"PromoCode"> | number
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdBy?: IntFilter<"PromoCode"> | number
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeFilter<"PromoCode"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    description?: StringNullableFilter<"PromoCode"> | string | null
    discountType?: StringFilter<"PromoCode"> | string
    discountValue?: FloatFilter<"PromoCode"> | number
    maxUses?: IntNullableFilter<"PromoCode"> | number | null
    currentUses?: IntFilter<"PromoCode"> | number
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdBy?: IntFilter<"PromoCode"> | number
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeFilter<"PromoCode"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PromoCode"> | number
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    description?: StringNullableWithAggregatesFilter<"PromoCode"> | string | null
    discountType?: StringWithAggregatesFilter<"PromoCode"> | string
    discountValue?: FloatWithAggregatesFilter<"PromoCode"> | number
    maxUses?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    currentUses?: IntWithAggregatesFilter<"PromoCode"> | number
    validFrom?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeNullableWithAggregatesFilter<"PromoCode"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"PromoCode"> | boolean
    createdBy?: IntWithAggregatesFilter<"PromoCode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    category?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    category?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    category?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainCreateInput = {
    domainName: string
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutDomainInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateInput = {
    id?: number
    domainName: string
    userId: number
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainUpdateInput = {
    domainName?: StringFieldUpdateOperationsInput | string
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDomainNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainCreateManyInput = {
    id?: number
    domainName: string
    userId: number
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DomainUpdateManyMutationInput = {
    domainName?: StringFieldUpdateOperationsInput | string
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAccountCreateInput = {
    address: string
    password: string
    storageUsed?: number
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
    domain: DomainCreateNestedOneWithoutEmailAccountsInput
    owner?: UserCreateNestedOneWithoutEmailAccountsInput
    emails?: EmailCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUncheckedCreateInput = {
    id?: number
    address: string
    password: string
    storageUsed?: number
    domainId: number
    ownerId?: number | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
    emails?: EmailUncheckedCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneRequiredWithoutEmailAccountsNestedInput
    owner?: UserUpdateOneWithoutEmailAccountsNestedInput
    emails?: EmailUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountCreateManyInput = {
    id?: number
    address: string
    password: string
    storageUsed?: number
    domainId: number
    ownerId?: number | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
  }

  export type EmailAccountUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCreateInput = {
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
    account: EmailAccountCreateNestedOneWithoutEmailsInput
    attachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateInput = {
    id?: number
    emailAccountId: number
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
    attachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailUpdateInput = {
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: EmailAccountUpdateOneRequiredWithoutEmailsNestedInput
    attachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailAccountId?: IntFieldUpdateOperationsInput | number
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type EmailCreateManyInput = {
    id?: number
    emailAccountId: number
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
  }

  export type EmailUpdateManyMutationInput = {
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailAccountId?: IntFieldUpdateOperationsInput | number
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanCreateInput = {
    name: string
    description?: string | null
    priceMonthly: number
    priceYearly: number
    maxEmails?: number
    maxStorageGB?: number
    maxDomains?: number
    features?: string | null
    category?: string
    isActive?: boolean
    createdAt?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    priceMonthly: number
    priceYearly: number
    maxEmails?: number
    maxStorageGB?: number
    maxDomains?: number
    features?: string | null
    category?: string
    isActive?: boolean
    createdAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    maxEmails?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: IntFieldUpdateOperationsInput | number
    maxDomains?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    maxEmails?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: IntFieldUpdateOperationsInput | number
    maxDomains?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    priceMonthly: number
    priceYearly: number
    maxEmails?: number
    maxStorageGB?: number
    maxDomains?: number
    features?: string | null
    category?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    maxEmails?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: IntFieldUpdateOperationsInput | number
    maxDomains?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    maxEmails?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: IntFieldUpdateOperationsInput | number
    maxDomains?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    user: UserCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    Plan?: PlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    userId: number
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    planId?: number | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    Plan?: PlanUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    userId: number
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    planId?: number | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InvoiceCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
    subscription?: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    userId: number
    subscriptionId?: number | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    subscription?: SubscriptionUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: number
    userId: number
    subscriptionId?: number | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: number
    userId: number
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: number
    userId: number
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentCreateInput = {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutAttachmentsInput
  }

  export type TicketAttachmentUncheckedCreateInput = {
    id?: number
    ticketId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TicketAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentCreateManyInput = {
    id?: number
    ticketId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageCreateInput = {
    message: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutTicketMessagesInput
  }

  export type TicketMessageUncheckedCreateInput = {
    id?: number
    ticketId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type TicketMessageUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutTicketMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageCreateManyInput = {
    id?: number
    ticketId: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type TicketMessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentCreateInput = {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    contentId?: string | null
    createdAt?: Date | string
    email: EmailCreateNestedOneWithoutAttachmentsInput
  }

  export type EmailAttachmentUncheckedCreateInput = {
    id?: number
    emailId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    contentId?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type EmailAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentCreateManyInput = {
    id?: number
    emailId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    contentId?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthApplicationCreateInput = {
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOauthApplicationsInput
    authCodes?: OAuthAuthCodeCreateNestedManyWithoutApplicationInput
    accessTokens?: OAuthAccessTokenCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutApplicationInput
    accessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthApplicationsNestedInput
    authCodes?: OAuthAuthCodeUpdateManyWithoutApplicationNestedInput
    accessTokens?: OAuthAccessTokenUpdateManyWithoutApplicationNestedInput
  }

  export type OAuthApplicationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutApplicationNestedInput
    accessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type OAuthApplicationCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthApplicationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthApplicationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthCodeCreateInput = {
    code: string
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    application: OAuthApplicationCreateNestedOneWithoutAuthCodesInput
    user: UserCreateNestedOneWithoutOauthAuthCodesInput
  }

  export type OAuthAuthCodeUncheckedCreateInput = {
    id?: number
    code: string
    applicationId: number
    userId: number
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OAuthAuthCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: OAuthApplicationUpdateOneRequiredWithoutAuthCodesNestedInput
    user?: UserUpdateOneRequiredWithoutOauthAuthCodesNestedInput
  }

  export type OAuthAuthCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthCodeCreateManyInput = {
    id?: number
    code: string
    applicationId: number
    userId: number
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OAuthAuthCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenCreateInput = {
    token: string
    refreshToken?: string | null
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    application: OAuthApplicationCreateNestedOneWithoutAccessTokensInput
    user: UserCreateNestedOneWithoutOauthAccessTokensInput
  }

  export type OAuthAccessTokenUncheckedCreateInput = {
    id?: number
    token: string
    refreshToken?: string | null
    applicationId: number
    userId: number
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAccessTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: OAuthApplicationUpdateOneRequiredWithoutAccessTokensNestedInput
    user?: UserUpdateOneRequiredWithoutOauthAccessTokensNestedInput
  }

  export type OAuthAccessTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenCreateManyInput = {
    id?: number
    token: string
    refreshToken?: string | null
    applicationId: number
    userId: number
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAccessTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateInput = {
    code: string
    description?: string | null
    discountType?: string
    discountValue: number
    maxUses?: number | null
    currentUses?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPromoCodesInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: string
    discountValue: number
    maxUses?: number | null
    currentUses?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    isActive?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateManyInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: string
    discountValue: number
    maxUses?: number | null
    currentUses?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    isActive?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    type: string
    category?: string | null
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    category?: string | null
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    type: string
    category?: string | null
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DomainListRelationFilter = {
    every?: DomainWhereInput
    some?: DomainWhereInput
    none?: DomainWhereInput
  }

  export type EmailAccountListRelationFilter = {
    every?: EmailAccountWhereInput
    some?: EmailAccountWhereInput
    none?: EmailAccountWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type TicketMessageListRelationFilter = {
    every?: TicketMessageWhereInput
    some?: TicketMessageWhereInput
    none?: TicketMessageWhereInput
  }

  export type OAuthApplicationListRelationFilter = {
    every?: OAuthApplicationWhereInput
    some?: OAuthApplicationWhereInput
    none?: OAuthApplicationWhereInput
  }

  export type OAuthAuthCodeListRelationFilter = {
    every?: OAuthAuthCodeWhereInput
    some?: OAuthAuthCodeWhereInput
    none?: OAuthAuthCodeWhereInput
  }

  export type OAuthAccessTokenListRelationFilter = {
    every?: OAuthAccessTokenWhereInput
    some?: OAuthAccessTokenWhereInput
    none?: OAuthAccessTokenWhereInput
  }

  export type PromoCodeListRelationFilter = {
    every?: PromoCodeWhereInput
    some?: PromoCodeWhereInput
    none?: PromoCodeWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthAuthCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthAccessTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    paymentMethod?: SortOrder
    paymentDetails?: SortOrder
    recoveryEmail?: SortOrder
    recoveryPhone?: SortOrder
    recoveryPhoneCountryCode?: SortOrder
    allowEmailRecovery?: SortOrder
    allowPhoneRecovery?: SortOrder
    allowQRLogin?: SortOrder
    recoveryPhrase?: SortOrder
    allowRecoveryPhrase?: SortOrder
    allowDeviceRecovery?: SortOrder
    recoveryFileHash?: SortOrder
    preferences?: SortOrder
    credits?: SortOrder
    appliedGiftCodes?: SortOrder
    twoPasswordMode?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    twoFactorSecret?: SortOrder
    emergencyContacts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    paymentMethod?: SortOrder
    paymentDetails?: SortOrder
    recoveryEmail?: SortOrder
    recoveryPhone?: SortOrder
    recoveryPhoneCountryCode?: SortOrder
    allowEmailRecovery?: SortOrder
    allowPhoneRecovery?: SortOrder
    allowQRLogin?: SortOrder
    recoveryPhrase?: SortOrder
    allowRecoveryPhrase?: SortOrder
    allowDeviceRecovery?: SortOrder
    recoveryFileHash?: SortOrder
    preferences?: SortOrder
    credits?: SortOrder
    appliedGiftCodes?: SortOrder
    twoPasswordMode?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    twoFactorSecret?: SortOrder
    emergencyContacts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    paymentMethod?: SortOrder
    paymentDetails?: SortOrder
    recoveryEmail?: SortOrder
    recoveryPhone?: SortOrder
    recoveryPhoneCountryCode?: SortOrder
    allowEmailRecovery?: SortOrder
    allowPhoneRecovery?: SortOrder
    allowQRLogin?: SortOrder
    recoveryPhrase?: SortOrder
    allowRecoveryPhrase?: SortOrder
    allowDeviceRecovery?: SortOrder
    recoveryFileHash?: SortOrder
    preferences?: SortOrder
    credits?: SortOrder
    appliedGiftCodes?: SortOrder
    twoPasswordMode?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    twoFactorSecret?: SortOrder
    emergencyContacts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    credits?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DomainCountOrderByAggregateInput = {
    id?: SortOrder
    domainName?: SortOrder
    userId?: SortOrder
    dnsVerified?: SortOrder
    mxRecord?: SortOrder
    spfRecord?: SortOrder
    dkimRecord?: SortOrder
    dmarcRecord?: SortOrder
    lastDnsCheck?: SortOrder
    smtpProvider?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    smtpPort?: SortOrder
  }

  export type DomainMaxOrderByAggregateInput = {
    id?: SortOrder
    domainName?: SortOrder
    userId?: SortOrder
    dnsVerified?: SortOrder
    mxRecord?: SortOrder
    spfRecord?: SortOrder
    dkimRecord?: SortOrder
    dmarcRecord?: SortOrder
    lastDnsCheck?: SortOrder
    smtpProvider?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainMinOrderByAggregateInput = {
    id?: SortOrder
    domainName?: SortOrder
    userId?: SortOrder
    dnsVerified?: SortOrder
    mxRecord?: SortOrder
    spfRecord?: SortOrder
    dkimRecord?: SortOrder
    dmarcRecord?: SortOrder
    lastDnsCheck?: SortOrder
    smtpProvider?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpApiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    smtpPort?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DomainRelationFilter = {
    is?: DomainWhereInput
    isNot?: DomainWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EmailListRelationFilter = {
    every?: EmailWhereInput
    some?: EmailWhereInput
    none?: EmailWhereInput
  }

  export type EmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAccountCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    password?: SortOrder
    storageUsed?: SortOrder
    domainId?: SortOrder
    ownerId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    storageUsed?: SortOrder
    domainId?: SortOrder
    ownerId?: SortOrder
    smtpPort?: SortOrder
  }

  export type EmailAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    password?: SortOrder
    storageUsed?: SortOrder
    domainId?: SortOrder
    ownerId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAccountMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    password?: SortOrder
    storageUsed?: SortOrder
    domainId?: SortOrder
    ownerId?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAccountSumOrderByAggregateInput = {
    id?: SortOrder
    storageUsed?: SortOrder
    domainId?: SortOrder
    ownerId?: SortOrder
    smtpPort?: SortOrder
  }

  export type EmailAccountRelationFilter = {
    is?: EmailAccountWhereInput
    isNot?: EmailAccountWhereInput
  }

  export type EmailAttachmentListRelationFilter = {
    every?: EmailAttachmentWhereInput
    some?: EmailAttachmentWhereInput
    none?: EmailAttachmentWhereInput
  }

  export type EmailAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailCountOrderByAggregateInput = {
    id?: SortOrder
    emailAccountId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    htmlBody?: SortOrder
    isRead?: SortOrder
    isSent?: SortOrder
    messageId?: SortOrder
    inReplyTo?: SortOrder
    references?: SortOrder
    priority?: SortOrder
    receivedAt?: SortOrder
    sentAt?: SortOrder
    isStarred?: SortOrder
    isArchived?: SortOrder
    isSpam?: SortOrder
    isImportant?: SortOrder
    isDraft?: SortOrder
    isDeleted?: SortOrder
    folderId?: SortOrder
    labels?: SortOrder
    scheduledFor?: SortOrder
  }

  export type EmailAvgOrderByAggregateInput = {
    id?: SortOrder
    emailAccountId?: SortOrder
    folderId?: SortOrder
  }

  export type EmailMaxOrderByAggregateInput = {
    id?: SortOrder
    emailAccountId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    htmlBody?: SortOrder
    isRead?: SortOrder
    isSent?: SortOrder
    messageId?: SortOrder
    inReplyTo?: SortOrder
    references?: SortOrder
    priority?: SortOrder
    receivedAt?: SortOrder
    sentAt?: SortOrder
    isStarred?: SortOrder
    isArchived?: SortOrder
    isSpam?: SortOrder
    isImportant?: SortOrder
    isDraft?: SortOrder
    isDeleted?: SortOrder
    folderId?: SortOrder
    labels?: SortOrder
    scheduledFor?: SortOrder
  }

  export type EmailMinOrderByAggregateInput = {
    id?: SortOrder
    emailAccountId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    htmlBody?: SortOrder
    isRead?: SortOrder
    isSent?: SortOrder
    messageId?: SortOrder
    inReplyTo?: SortOrder
    references?: SortOrder
    priority?: SortOrder
    receivedAt?: SortOrder
    sentAt?: SortOrder
    isStarred?: SortOrder
    isArchived?: SortOrder
    isSpam?: SortOrder
    isImportant?: SortOrder
    isDraft?: SortOrder
    isDeleted?: SortOrder
    folderId?: SortOrder
    labels?: SortOrder
    scheduledFor?: SortOrder
  }

  export type EmailSumOrderByAggregateInput = {
    id?: SortOrder
    emailAccountId?: SortOrder
    folderId?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxEmails?: SortOrder
    maxStorageGB?: SortOrder
    maxDomains?: SortOrder
    features?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    id?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxEmails?: SortOrder
    maxStorageGB?: SortOrder
    maxDomains?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxEmails?: SortOrder
    maxStorageGB?: SortOrder
    maxDomains?: SortOrder
    features?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxEmails?: SortOrder
    maxStorageGB?: SortOrder
    maxDomains?: SortOrder
    features?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    id?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxEmails?: SortOrder
    maxStorageGB?: SortOrder
    maxDomains?: SortOrder
  }

  export type PlanNullableRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    planId?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    planId?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    planId?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
  }

  export type TicketAttachmentListRelationFilter = {
    every?: TicketAttachmentWhereInput
    some?: TicketAttachmentWhereInput
    none?: TicketAttachmentWhereInput
  }

  export type TicketAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TicketRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    fileSize?: SortOrder
  }

  export type TicketAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    fileSize?: SortOrder
  }

  export type TicketMessageCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
  }

  export type TicketMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
  }

  export type EmailRelationFilter = {
    is?: EmailWhereInput
    isNot?: EmailWhereInput
  }

  export type EmailAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    fileSize?: SortOrder
  }

  export type EmailAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    fileSize?: SortOrder
  }

  export type OAuthApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthApplicationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OAuthApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    redirectUris?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthApplicationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type OAuthApplicationRelationFilter = {
    is?: OAuthApplicationWhereInput
    isNot?: OAuthApplicationWhereInput
  }

  export type OAuthAuthCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAuthCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
  }

  export type OAuthAuthCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAuthCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAuthCodeSumOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
  }

  export type OAuthAccessTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAccessTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
  }

  export type OAuthAccessTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAccessTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAccessTokenSumOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    userId?: SortOrder
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    createdBy?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrder
    currentUses?: SortOrder
    createdBy?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DomainCreateNestedManyWithoutUserInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
  }

  export type EmailAccountCreateNestedManyWithoutOwnerInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type OAuthApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthApplicationCreateWithoutUserInput, OAuthApplicationUncheckedCreateWithoutUserInput> | OAuthApplicationCreateWithoutUserInput[] | OAuthApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutUserInput | OAuthApplicationCreateOrConnectWithoutUserInput[]
    createMany?: OAuthApplicationCreateManyUserInputEnvelope
    connect?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
  }

  export type OAuthAuthCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutUserInput, OAuthAuthCodeUncheckedCreateWithoutUserInput> | OAuthAuthCodeCreateWithoutUserInput[] | OAuthAuthCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutUserInput | OAuthAuthCodeCreateOrConnectWithoutUserInput[]
    createMany?: OAuthAuthCodeCreateManyUserInputEnvelope
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
  }

  export type OAuthAccessTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutUserInput, OAuthAccessTokenUncheckedCreateWithoutUserInput> | OAuthAccessTokenCreateWithoutUserInput[] | OAuthAccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutUserInput | OAuthAccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: OAuthAccessTokenCreateManyUserInputEnvelope
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
  }

  export type PromoCodeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PromoCodeCreateWithoutCreatorInput, PromoCodeUncheckedCreateWithoutCreatorInput> | PromoCodeCreateWithoutCreatorInput[] | PromoCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutCreatorInput | PromoCodeCreateOrConnectWithoutCreatorInput[]
    createMany?: PromoCodeCreateManyCreatorInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DomainUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
  }

  export type EmailAccountUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type OAuthApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthApplicationCreateWithoutUserInput, OAuthApplicationUncheckedCreateWithoutUserInput> | OAuthApplicationCreateWithoutUserInput[] | OAuthApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutUserInput | OAuthApplicationCreateOrConnectWithoutUserInput[]
    createMany?: OAuthApplicationCreateManyUserInputEnvelope
    connect?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
  }

  export type OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutUserInput, OAuthAuthCodeUncheckedCreateWithoutUserInput> | OAuthAuthCodeCreateWithoutUserInput[] | OAuthAuthCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutUserInput | OAuthAuthCodeCreateOrConnectWithoutUserInput[]
    createMany?: OAuthAuthCodeCreateManyUserInputEnvelope
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
  }

  export type OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutUserInput, OAuthAccessTokenUncheckedCreateWithoutUserInput> | OAuthAccessTokenCreateWithoutUserInput[] | OAuthAccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutUserInput | OAuthAccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: OAuthAccessTokenCreateManyUserInputEnvelope
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
  }

  export type PromoCodeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PromoCodeCreateWithoutCreatorInput, PromoCodeUncheckedCreateWithoutCreatorInput> | PromoCodeCreateWithoutCreatorInput[] | PromoCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutCreatorInput | PromoCodeCreateOrConnectWithoutCreatorInput[]
    createMany?: PromoCodeCreateManyCreatorInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DomainUpdateManyWithoutUserNestedInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    upsert?: DomainUpsertWithWhereUniqueWithoutUserInput | DomainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    set?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    disconnect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    delete?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    update?: DomainUpdateWithWhereUniqueWithoutUserInput | DomainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DomainUpdateManyWithWhereWithoutUserInput | DomainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DomainScalarWhereInput | DomainScalarWhereInput[]
  }

  export type EmailAccountUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutOwnerInput | EmailAccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutOwnerInput | EmailAccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutOwnerInput | EmailAccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutUserInput | TicketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutUserInput | TicketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutUserInput | TicketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type OAuthApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthApplicationCreateWithoutUserInput, OAuthApplicationUncheckedCreateWithoutUserInput> | OAuthApplicationCreateWithoutUserInput[] | OAuthApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutUserInput | OAuthApplicationCreateOrConnectWithoutUserInput[]
    upsert?: OAuthApplicationUpsertWithWhereUniqueWithoutUserInput | OAuthApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthApplicationCreateManyUserInputEnvelope
    set?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    disconnect?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    delete?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    connect?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    update?: OAuthApplicationUpdateWithWhereUniqueWithoutUserInput | OAuthApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthApplicationUpdateManyWithWhereWithoutUserInput | OAuthApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthApplicationScalarWhereInput | OAuthApplicationScalarWhereInput[]
  }

  export type OAuthAuthCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutUserInput, OAuthAuthCodeUncheckedCreateWithoutUserInput> | OAuthAuthCodeCreateWithoutUserInput[] | OAuthAuthCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutUserInput | OAuthAuthCodeCreateOrConnectWithoutUserInput[]
    upsert?: OAuthAuthCodeUpsertWithWhereUniqueWithoutUserInput | OAuthAuthCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthAuthCodeCreateManyUserInputEnvelope
    set?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    disconnect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    delete?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    update?: OAuthAuthCodeUpdateWithWhereUniqueWithoutUserInput | OAuthAuthCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthAuthCodeUpdateManyWithWhereWithoutUserInput | OAuthAuthCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthAuthCodeScalarWhereInput | OAuthAuthCodeScalarWhereInput[]
  }

  export type OAuthAccessTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutUserInput, OAuthAccessTokenUncheckedCreateWithoutUserInput> | OAuthAccessTokenCreateWithoutUserInput[] | OAuthAccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutUserInput | OAuthAccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: OAuthAccessTokenUpsertWithWhereUniqueWithoutUserInput | OAuthAccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthAccessTokenCreateManyUserInputEnvelope
    set?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    disconnect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    delete?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    update?: OAuthAccessTokenUpdateWithWhereUniqueWithoutUserInput | OAuthAccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthAccessTokenUpdateManyWithWhereWithoutUserInput | OAuthAccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
  }

  export type PromoCodeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PromoCodeCreateWithoutCreatorInput, PromoCodeUncheckedCreateWithoutCreatorInput> | PromoCodeCreateWithoutCreatorInput[] | PromoCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutCreatorInput | PromoCodeCreateOrConnectWithoutCreatorInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutCreatorInput | PromoCodeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PromoCodeCreateManyCreatorInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutCreatorInput | PromoCodeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutCreatorInput | PromoCodeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DomainUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput> | DomainCreateWithoutUserInput[] | DomainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainCreateOrConnectWithoutUserInput | DomainCreateOrConnectWithoutUserInput[]
    upsert?: DomainUpsertWithWhereUniqueWithoutUserInput | DomainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DomainCreateManyUserInputEnvelope
    set?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    disconnect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    delete?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    connect?: DomainWhereUniqueInput | DomainWhereUniqueInput[]
    update?: DomainUpdateWithWhereUniqueWithoutUserInput | DomainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DomainUpdateManyWithWhereWithoutUserInput | DomainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DomainScalarWhereInput | DomainScalarWhereInput[]
  }

  export type EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutOwnerInput | EmailAccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutOwnerInput | EmailAccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutOwnerInput | EmailAccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutUserInput | TicketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutUserInput | TicketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutUserInput | TicketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthApplicationCreateWithoutUserInput, OAuthApplicationUncheckedCreateWithoutUserInput> | OAuthApplicationCreateWithoutUserInput[] | OAuthApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutUserInput | OAuthApplicationCreateOrConnectWithoutUserInput[]
    upsert?: OAuthApplicationUpsertWithWhereUniqueWithoutUserInput | OAuthApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthApplicationCreateManyUserInputEnvelope
    set?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    disconnect?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    delete?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    connect?: OAuthApplicationWhereUniqueInput | OAuthApplicationWhereUniqueInput[]
    update?: OAuthApplicationUpdateWithWhereUniqueWithoutUserInput | OAuthApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthApplicationUpdateManyWithWhereWithoutUserInput | OAuthApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthApplicationScalarWhereInput | OAuthApplicationScalarWhereInput[]
  }

  export type OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutUserInput, OAuthAuthCodeUncheckedCreateWithoutUserInput> | OAuthAuthCodeCreateWithoutUserInput[] | OAuthAuthCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutUserInput | OAuthAuthCodeCreateOrConnectWithoutUserInput[]
    upsert?: OAuthAuthCodeUpsertWithWhereUniqueWithoutUserInput | OAuthAuthCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthAuthCodeCreateManyUserInputEnvelope
    set?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    disconnect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    delete?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    update?: OAuthAuthCodeUpdateWithWhereUniqueWithoutUserInput | OAuthAuthCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthAuthCodeUpdateManyWithWhereWithoutUserInput | OAuthAuthCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthAuthCodeScalarWhereInput | OAuthAuthCodeScalarWhereInput[]
  }

  export type OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutUserInput, OAuthAccessTokenUncheckedCreateWithoutUserInput> | OAuthAccessTokenCreateWithoutUserInput[] | OAuthAccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutUserInput | OAuthAccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: OAuthAccessTokenUpsertWithWhereUniqueWithoutUserInput | OAuthAccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthAccessTokenCreateManyUserInputEnvelope
    set?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    disconnect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    delete?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    update?: OAuthAccessTokenUpdateWithWhereUniqueWithoutUserInput | OAuthAccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthAccessTokenUpdateManyWithWhereWithoutUserInput | OAuthAccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
  }

  export type PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PromoCodeCreateWithoutCreatorInput, PromoCodeUncheckedCreateWithoutCreatorInput> | PromoCodeCreateWithoutCreatorInput[] | PromoCodeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutCreatorInput | PromoCodeCreateOrConnectWithoutCreatorInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutCreatorInput | PromoCodeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PromoCodeCreateManyCreatorInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutCreatorInput | PromoCodeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutCreatorInput | PromoCodeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDomainInput = {
    create?: XOR<UserCreateWithoutDomainInput, UserUncheckedCreateWithoutDomainInput>
    connectOrCreate?: UserCreateOrConnectWithoutDomainInput
    connect?: UserWhereUniqueInput
  }

  export type EmailAccountCreateNestedManyWithoutDomainInput = {
    create?: XOR<EmailAccountCreateWithoutDomainInput, EmailAccountUncheckedCreateWithoutDomainInput> | EmailAccountCreateWithoutDomainInput[] | EmailAccountUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutDomainInput | EmailAccountCreateOrConnectWithoutDomainInput[]
    createMany?: EmailAccountCreateManyDomainInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type EmailAccountUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<EmailAccountCreateWithoutDomainInput, EmailAccountUncheckedCreateWithoutDomainInput> | EmailAccountCreateWithoutDomainInput[] | EmailAccountUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutDomainInput | EmailAccountCreateOrConnectWithoutDomainInput[]
    createMany?: EmailAccountCreateManyDomainInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDomainNestedInput = {
    create?: XOR<UserCreateWithoutDomainInput, UserUncheckedCreateWithoutDomainInput>
    connectOrCreate?: UserCreateOrConnectWithoutDomainInput
    upsert?: UserUpsertWithoutDomainInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDomainInput, UserUpdateWithoutDomainInput>, UserUncheckedUpdateWithoutDomainInput>
  }

  export type EmailAccountUpdateManyWithoutDomainNestedInput = {
    create?: XOR<EmailAccountCreateWithoutDomainInput, EmailAccountUncheckedCreateWithoutDomainInput> | EmailAccountCreateWithoutDomainInput[] | EmailAccountUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutDomainInput | EmailAccountCreateOrConnectWithoutDomainInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutDomainInput | EmailAccountUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: EmailAccountCreateManyDomainInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutDomainInput | EmailAccountUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutDomainInput | EmailAccountUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type EmailAccountUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<EmailAccountCreateWithoutDomainInput, EmailAccountUncheckedCreateWithoutDomainInput> | EmailAccountCreateWithoutDomainInput[] | EmailAccountUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutDomainInput | EmailAccountCreateOrConnectWithoutDomainInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutDomainInput | EmailAccountUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: EmailAccountCreateManyDomainInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutDomainInput | EmailAccountUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutDomainInput | EmailAccountUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type DomainCreateNestedOneWithoutEmailAccountsInput = {
    create?: XOR<DomainCreateWithoutEmailAccountsInput, DomainUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutEmailAccountsInput
    connect?: DomainWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailAccountsInput = {
    create?: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EmailCreateNestedManyWithoutAccountInput = {
    create?: XOR<EmailCreateWithoutAccountInput, EmailUncheckedCreateWithoutAccountInput> | EmailCreateWithoutAccountInput[] | EmailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutAccountInput | EmailCreateOrConnectWithoutAccountInput[]
    createMany?: EmailCreateManyAccountInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<EmailCreateWithoutAccountInput, EmailUncheckedCreateWithoutAccountInput> | EmailCreateWithoutAccountInput[] | EmailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutAccountInput | EmailCreateOrConnectWithoutAccountInput[]
    createMany?: EmailCreateManyAccountInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type DomainUpdateOneRequiredWithoutEmailAccountsNestedInput = {
    create?: XOR<DomainCreateWithoutEmailAccountsInput, DomainUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: DomainCreateOrConnectWithoutEmailAccountsInput
    upsert?: DomainUpsertWithoutEmailAccountsInput
    connect?: DomainWhereUniqueInput
    update?: XOR<XOR<DomainUpdateToOneWithWhereWithoutEmailAccountsInput, DomainUpdateWithoutEmailAccountsInput>, DomainUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type UserUpdateOneWithoutEmailAccountsNestedInput = {
    create?: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailAccountsInput
    upsert?: UserUpsertWithoutEmailAccountsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailAccountsInput, UserUpdateWithoutEmailAccountsInput>, UserUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type EmailUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EmailCreateWithoutAccountInput, EmailUncheckedCreateWithoutAccountInput> | EmailCreateWithoutAccountInput[] | EmailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutAccountInput | EmailCreateOrConnectWithoutAccountInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutAccountInput | EmailUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EmailCreateManyAccountInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutAccountInput | EmailUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutAccountInput | EmailUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EmailCreateWithoutAccountInput, EmailUncheckedCreateWithoutAccountInput> | EmailCreateWithoutAccountInput[] | EmailUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutAccountInput | EmailCreateOrConnectWithoutAccountInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutAccountInput | EmailUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EmailCreateManyAccountInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutAccountInput | EmailUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutAccountInput | EmailUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailAccountCreateNestedOneWithoutEmailsInput = {
    create?: XOR<EmailAccountCreateWithoutEmailsInput, EmailAccountUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: EmailAccountCreateOrConnectWithoutEmailsInput
    connect?: EmailAccountWhereUniqueInput
  }

  export type EmailAttachmentCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
  }

  export type EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
  }

  export type EmailAccountUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<EmailAccountCreateWithoutEmailsInput, EmailAccountUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: EmailAccountCreateOrConnectWithoutEmailsInput
    upsert?: EmailAccountUpsertWithoutEmailsInput
    connect?: EmailAccountWhereUniqueInput
    update?: XOR<XOR<EmailAccountUpdateToOneWithWhereWithoutEmailsInput, EmailAccountUpdateWithoutEmailsInput>, EmailAccountUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailAttachmentUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    upsert?: EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput | EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    set?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    disconnect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    delete?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    update?: EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput | EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailAttachmentUpdateManyWithWhereWithoutEmailInput | EmailAttachmentUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
  }

  export type EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    upsert?: EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput | EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    set?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    disconnect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    delete?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    update?: EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput | EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailAttachmentUpdateManyWithWhereWithoutEmailInput | EmailAttachmentUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PlanUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PlanUpsertWithoutSubscriptionsInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionsInput, PlanUpdateWithoutSubscriptionsInput>, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    upsert?: SubscriptionUpsertWithoutInvoicesInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoicesInput, SubscriptionUpdateWithoutInvoicesInput>, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketAttachmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketMessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TicketMessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketAttachmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketMessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    upsert?: TicketUpsertWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutAttachmentsInput, TicketUpdateWithoutAttachmentsInput>, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketMessagesInput = {
    create?: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    upsert?: TicketUpsertWithoutMessagesInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutMessagesInput, TicketUpdateWithoutMessagesInput>, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutTicketMessagesNestedInput = {
    create?: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketMessagesInput
    upsert?: UserUpsertWithoutTicketMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketMessagesInput, UserUpdateWithoutTicketMessagesInput>, UserUncheckedUpdateWithoutTicketMessagesInput>
  }

  export type EmailCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutAttachmentsInput
    connect?: EmailWhereUniqueInput
  }

  export type EmailUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutAttachmentsInput
    upsert?: EmailUpsertWithoutAttachmentsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutAttachmentsInput, EmailUpdateWithoutAttachmentsInput>, EmailUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutOauthApplicationsInput = {
    create?: XOR<UserCreateWithoutOauthApplicationsInput, UserUncheckedCreateWithoutOauthApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type OAuthAuthCodeCreateNestedManyWithoutApplicationInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutApplicationInput, OAuthAuthCodeUncheckedCreateWithoutApplicationInput> | OAuthAuthCodeCreateWithoutApplicationInput[] | OAuthAuthCodeUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutApplicationInput | OAuthAuthCodeCreateOrConnectWithoutApplicationInput[]
    createMany?: OAuthAuthCodeCreateManyApplicationInputEnvelope
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
  }

  export type OAuthAccessTokenCreateNestedManyWithoutApplicationInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutApplicationInput, OAuthAccessTokenUncheckedCreateWithoutApplicationInput> | OAuthAccessTokenCreateWithoutApplicationInput[] | OAuthAccessTokenUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutApplicationInput | OAuthAccessTokenCreateOrConnectWithoutApplicationInput[]
    createMany?: OAuthAccessTokenCreateManyApplicationInputEnvelope
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
  }

  export type OAuthAuthCodeUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutApplicationInput, OAuthAuthCodeUncheckedCreateWithoutApplicationInput> | OAuthAuthCodeCreateWithoutApplicationInput[] | OAuthAuthCodeUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutApplicationInput | OAuthAuthCodeCreateOrConnectWithoutApplicationInput[]
    createMany?: OAuthAuthCodeCreateManyApplicationInputEnvelope
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
  }

  export type OAuthAccessTokenUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutApplicationInput, OAuthAccessTokenUncheckedCreateWithoutApplicationInput> | OAuthAccessTokenCreateWithoutApplicationInput[] | OAuthAccessTokenUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutApplicationInput | OAuthAccessTokenCreateOrConnectWithoutApplicationInput[]
    createMany?: OAuthAccessTokenCreateManyApplicationInputEnvelope
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOauthApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutOauthApplicationsInput, UserUncheckedCreateWithoutOauthApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthApplicationsInput
    upsert?: UserUpsertWithoutOauthApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthApplicationsInput, UserUpdateWithoutOauthApplicationsInput>, UserUncheckedUpdateWithoutOauthApplicationsInput>
  }

  export type OAuthAuthCodeUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutApplicationInput, OAuthAuthCodeUncheckedCreateWithoutApplicationInput> | OAuthAuthCodeCreateWithoutApplicationInput[] | OAuthAuthCodeUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutApplicationInput | OAuthAuthCodeCreateOrConnectWithoutApplicationInput[]
    upsert?: OAuthAuthCodeUpsertWithWhereUniqueWithoutApplicationInput | OAuthAuthCodeUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: OAuthAuthCodeCreateManyApplicationInputEnvelope
    set?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    disconnect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    delete?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    update?: OAuthAuthCodeUpdateWithWhereUniqueWithoutApplicationInput | OAuthAuthCodeUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: OAuthAuthCodeUpdateManyWithWhereWithoutApplicationInput | OAuthAuthCodeUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: OAuthAuthCodeScalarWhereInput | OAuthAuthCodeScalarWhereInput[]
  }

  export type OAuthAccessTokenUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutApplicationInput, OAuthAccessTokenUncheckedCreateWithoutApplicationInput> | OAuthAccessTokenCreateWithoutApplicationInput[] | OAuthAccessTokenUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutApplicationInput | OAuthAccessTokenCreateOrConnectWithoutApplicationInput[]
    upsert?: OAuthAccessTokenUpsertWithWhereUniqueWithoutApplicationInput | OAuthAccessTokenUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: OAuthAccessTokenCreateManyApplicationInputEnvelope
    set?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    disconnect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    delete?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    update?: OAuthAccessTokenUpdateWithWhereUniqueWithoutApplicationInput | OAuthAccessTokenUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: OAuthAccessTokenUpdateManyWithWhereWithoutApplicationInput | OAuthAccessTokenUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
  }

  export type OAuthAuthCodeUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<OAuthAuthCodeCreateWithoutApplicationInput, OAuthAuthCodeUncheckedCreateWithoutApplicationInput> | OAuthAuthCodeCreateWithoutApplicationInput[] | OAuthAuthCodeUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAuthCodeCreateOrConnectWithoutApplicationInput | OAuthAuthCodeCreateOrConnectWithoutApplicationInput[]
    upsert?: OAuthAuthCodeUpsertWithWhereUniqueWithoutApplicationInput | OAuthAuthCodeUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: OAuthAuthCodeCreateManyApplicationInputEnvelope
    set?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    disconnect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    delete?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    connect?: OAuthAuthCodeWhereUniqueInput | OAuthAuthCodeWhereUniqueInput[]
    update?: OAuthAuthCodeUpdateWithWhereUniqueWithoutApplicationInput | OAuthAuthCodeUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: OAuthAuthCodeUpdateManyWithWhereWithoutApplicationInput | OAuthAuthCodeUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: OAuthAuthCodeScalarWhereInput | OAuthAuthCodeScalarWhereInput[]
  }

  export type OAuthAccessTokenUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutApplicationInput, OAuthAccessTokenUncheckedCreateWithoutApplicationInput> | OAuthAccessTokenCreateWithoutApplicationInput[] | OAuthAccessTokenUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutApplicationInput | OAuthAccessTokenCreateOrConnectWithoutApplicationInput[]
    upsert?: OAuthAccessTokenUpsertWithWhereUniqueWithoutApplicationInput | OAuthAccessTokenUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: OAuthAccessTokenCreateManyApplicationInputEnvelope
    set?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    disconnect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    delete?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    update?: OAuthAccessTokenUpdateWithWhereUniqueWithoutApplicationInput | OAuthAccessTokenUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: OAuthAccessTokenUpdateManyWithWhereWithoutApplicationInput | OAuthAccessTokenUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
  }

  export type OAuthApplicationCreateNestedOneWithoutAuthCodesInput = {
    create?: XOR<OAuthApplicationCreateWithoutAuthCodesInput, OAuthApplicationUncheckedCreateWithoutAuthCodesInput>
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutAuthCodesInput
    connect?: OAuthApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOauthAuthCodesInput = {
    create?: XOR<UserCreateWithoutOauthAuthCodesInput, UserUncheckedCreateWithoutOauthAuthCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAuthCodesInput
    connect?: UserWhereUniqueInput
  }

  export type OAuthApplicationUpdateOneRequiredWithoutAuthCodesNestedInput = {
    create?: XOR<OAuthApplicationCreateWithoutAuthCodesInput, OAuthApplicationUncheckedCreateWithoutAuthCodesInput>
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutAuthCodesInput
    upsert?: OAuthApplicationUpsertWithoutAuthCodesInput
    connect?: OAuthApplicationWhereUniqueInput
    update?: XOR<XOR<OAuthApplicationUpdateToOneWithWhereWithoutAuthCodesInput, OAuthApplicationUpdateWithoutAuthCodesInput>, OAuthApplicationUncheckedUpdateWithoutAuthCodesInput>
  }

  export type UserUpdateOneRequiredWithoutOauthAuthCodesNestedInput = {
    create?: XOR<UserCreateWithoutOauthAuthCodesInput, UserUncheckedCreateWithoutOauthAuthCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAuthCodesInput
    upsert?: UserUpsertWithoutOauthAuthCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthAuthCodesInput, UserUpdateWithoutOauthAuthCodesInput>, UserUncheckedUpdateWithoutOauthAuthCodesInput>
  }

  export type OAuthApplicationCreateNestedOneWithoutAccessTokensInput = {
    create?: XOR<OAuthApplicationCreateWithoutAccessTokensInput, OAuthApplicationUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutAccessTokensInput
    connect?: OAuthApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOauthAccessTokensInput = {
    create?: XOR<UserCreateWithoutOauthAccessTokensInput, UserUncheckedCreateWithoutOauthAccessTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAccessTokensInput
    connect?: UserWhereUniqueInput
  }

  export type OAuthApplicationUpdateOneRequiredWithoutAccessTokensNestedInput = {
    create?: XOR<OAuthApplicationCreateWithoutAccessTokensInput, OAuthApplicationUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: OAuthApplicationCreateOrConnectWithoutAccessTokensInput
    upsert?: OAuthApplicationUpsertWithoutAccessTokensInput
    connect?: OAuthApplicationWhereUniqueInput
    update?: XOR<XOR<OAuthApplicationUpdateToOneWithWhereWithoutAccessTokensInput, OAuthApplicationUpdateWithoutAccessTokensInput>, OAuthApplicationUncheckedUpdateWithoutAccessTokensInput>
  }

  export type UserUpdateOneRequiredWithoutOauthAccessTokensNestedInput = {
    create?: XOR<UserCreateWithoutOauthAccessTokensInput, UserUncheckedCreateWithoutOauthAccessTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAccessTokensInput
    upsert?: UserUpsertWithoutOauthAccessTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthAccessTokensInput, UserUpdateWithoutOauthAccessTokensInput>, UserUncheckedUpdateWithoutOauthAccessTokensInput>
  }

  export type UserCreateNestedOneWithoutCreatedPromoCodesInput = {
    create?: XOR<UserCreateWithoutCreatedPromoCodesInput, UserUncheckedCreateWithoutCreatedPromoCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPromoCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreatedPromoCodesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPromoCodesInput, UserUncheckedCreateWithoutCreatedPromoCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPromoCodesInput
    upsert?: UserUpsertWithoutCreatedPromoCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPromoCodesInput, UserUpdateWithoutCreatedPromoCodesInput>, UserUncheckedUpdateWithoutCreatedPromoCodesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DomainCreateWithoutUserInput = {
    domainName: string
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    emailAccounts?: EmailAccountCreateNestedManyWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutUserInput = {
    id?: number
    domainName: string
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutDomainInput
  }

  export type DomainCreateOrConnectWithoutUserInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput>
  }

  export type DomainCreateManyUserInputEnvelope = {
    data: DomainCreateManyUserInput | DomainCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailAccountCreateWithoutOwnerInput = {
    address: string
    password: string
    storageUsed?: number
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
    domain: DomainCreateNestedOneWithoutEmailAccountsInput
    emails?: EmailCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUncheckedCreateWithoutOwnerInput = {
    id?: number
    address: string
    password: string
    storageUsed?: number
    domainId: number
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
    emails?: EmailUncheckedCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountCreateOrConnectWithoutOwnerInput = {
    where: EmailAccountWhereUniqueInput
    create: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput>
  }

  export type EmailAccountCreateManyOwnerInputEnvelope = {
    data: EmailAccountCreateManyOwnerInput | EmailAccountCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    Plan?: PlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: number
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    planId?: number | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    createdAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: number
    subscriptionId?: number | null
    createdAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutUserInput = {
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutUserInput = {
    id?: number
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutUserInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketCreateManyUserInputEnvelope = {
    data: TicketCreateManyUserInput | TicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketMessageCreateWithoutUserInput = {
    message: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMessagesInput
  }

  export type TicketMessageUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId: number
    message: string
    createdAt?: Date | string
  }

  export type TicketMessageCreateOrConnectWithoutUserInput = {
    where: TicketMessageWhereUniqueInput
    create: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput>
  }

  export type TicketMessageCreateManyUserInputEnvelope = {
    data: TicketMessageCreateManyUserInput | TicketMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OAuthApplicationCreateWithoutUserInput = {
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authCodes?: OAuthAuthCodeCreateNestedManyWithoutApplicationInput
    accessTokens?: OAuthAccessTokenCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutApplicationInput
    accessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationCreateOrConnectWithoutUserInput = {
    where: OAuthApplicationWhereUniqueInput
    create: XOR<OAuthApplicationCreateWithoutUserInput, OAuthApplicationUncheckedCreateWithoutUserInput>
  }

  export type OAuthApplicationCreateManyUserInputEnvelope = {
    data: OAuthApplicationCreateManyUserInput | OAuthApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAuthCodeCreateWithoutUserInput = {
    code: string
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    application: OAuthApplicationCreateNestedOneWithoutAuthCodesInput
  }

  export type OAuthAuthCodeUncheckedCreateWithoutUserInput = {
    id?: number
    code: string
    applicationId: number
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OAuthAuthCodeCreateOrConnectWithoutUserInput = {
    where: OAuthAuthCodeWhereUniqueInput
    create: XOR<OAuthAuthCodeCreateWithoutUserInput, OAuthAuthCodeUncheckedCreateWithoutUserInput>
  }

  export type OAuthAuthCodeCreateManyUserInputEnvelope = {
    data: OAuthAuthCodeCreateManyUserInput | OAuthAuthCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAccessTokenCreateWithoutUserInput = {
    token: string
    refreshToken?: string | null
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    application: OAuthApplicationCreateNestedOneWithoutAccessTokensInput
  }

  export type OAuthAccessTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    refreshToken?: string | null
    applicationId: number
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAccessTokenCreateOrConnectWithoutUserInput = {
    where: OAuthAccessTokenWhereUniqueInput
    create: XOR<OAuthAccessTokenCreateWithoutUserInput, OAuthAccessTokenUncheckedCreateWithoutUserInput>
  }

  export type OAuthAccessTokenCreateManyUserInputEnvelope = {
    data: OAuthAccessTokenCreateManyUserInput | OAuthAccessTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeCreateWithoutCreatorInput = {
    code: string
    description?: string | null
    discountType?: string
    discountValue: number
    maxUses?: number | null
    currentUses?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUncheckedCreateWithoutCreatorInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: string
    discountValue: number
    maxUses?: number | null
    currentUses?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeCreateOrConnectWithoutCreatorInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutCreatorInput, PromoCodeUncheckedCreateWithoutCreatorInput>
  }

  export type PromoCodeCreateManyCreatorInputEnvelope = {
    data: PromoCodeCreateManyCreatorInput | PromoCodeCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: string
    category?: string | null
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    category?: string | null
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DomainUpsertWithWhereUniqueWithoutUserInput = {
    where: DomainWhereUniqueInput
    update: XOR<DomainUpdateWithoutUserInput, DomainUncheckedUpdateWithoutUserInput>
    create: XOR<DomainCreateWithoutUserInput, DomainUncheckedCreateWithoutUserInput>
  }

  export type DomainUpdateWithWhereUniqueWithoutUserInput = {
    where: DomainWhereUniqueInput
    data: XOR<DomainUpdateWithoutUserInput, DomainUncheckedUpdateWithoutUserInput>
  }

  export type DomainUpdateManyWithWhereWithoutUserInput = {
    where: DomainScalarWhereInput
    data: XOR<DomainUpdateManyMutationInput, DomainUncheckedUpdateManyWithoutUserInput>
  }

  export type DomainScalarWhereInput = {
    AND?: DomainScalarWhereInput | DomainScalarWhereInput[]
    OR?: DomainScalarWhereInput[]
    NOT?: DomainScalarWhereInput | DomainScalarWhereInput[]
    id?: IntFilter<"Domain"> | number
    domainName?: StringFilter<"Domain"> | string
    userId?: IntFilter<"Domain"> | number
    dnsVerified?: BoolFilter<"Domain"> | boolean
    mxRecord?: StringNullableFilter<"Domain"> | string | null
    spfRecord?: StringNullableFilter<"Domain"> | string | null
    dkimRecord?: StringNullableFilter<"Domain"> | string | null
    dmarcRecord?: StringNullableFilter<"Domain"> | string | null
    lastDnsCheck?: DateTimeNullableFilter<"Domain"> | Date | string | null
    smtpProvider?: StringNullableFilter<"Domain"> | string | null
    smtpHost?: StringNullableFilter<"Domain"> | string | null
    smtpPort?: IntNullableFilter<"Domain"> | number | null
    smtpUser?: StringNullableFilter<"Domain"> | string | null
    smtpPassword?: StringNullableFilter<"Domain"> | string | null
    smtpApiKey?: StringNullableFilter<"Domain"> | string | null
    createdAt?: DateTimeFilter<"Domain"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Domain"> | Date | string | null
  }

  export type EmailAccountUpsertWithWhereUniqueWithoutOwnerInput = {
    where: EmailAccountWhereUniqueInput
    update: XOR<EmailAccountUpdateWithoutOwnerInput, EmailAccountUncheckedUpdateWithoutOwnerInput>
    create: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput>
  }

  export type EmailAccountUpdateWithWhereUniqueWithoutOwnerInput = {
    where: EmailAccountWhereUniqueInput
    data: XOR<EmailAccountUpdateWithoutOwnerInput, EmailAccountUncheckedUpdateWithoutOwnerInput>
  }

  export type EmailAccountUpdateManyWithWhereWithoutOwnerInput = {
    where: EmailAccountScalarWhereInput
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyWithoutOwnerInput>
  }

  export type EmailAccountScalarWhereInput = {
    AND?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
    OR?: EmailAccountScalarWhereInput[]
    NOT?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
    id?: IntFilter<"EmailAccount"> | number
    address?: StringFilter<"EmailAccount"> | string
    password?: StringFilter<"EmailAccount"> | string
    storageUsed?: FloatFilter<"EmailAccount"> | number
    domainId?: IntFilter<"EmailAccount"> | number
    ownerId?: IntNullableFilter<"EmailAccount"> | number | null
    smtpHost?: StringNullableFilter<"EmailAccount"> | string | null
    smtpPort?: IntNullableFilter<"EmailAccount"> | number | null
    smtpUser?: StringNullableFilter<"EmailAccount"> | string | null
    smtpPassword?: StringNullableFilter<"EmailAccount"> | string | null
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: IntFilter<"Subscription"> | number
    userId?: IntFilter<"Subscription"> | number
    plan?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    planId?: IntNullableFilter<"Subscription"> | number | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    userId?: IntFilter<"Invoice"> | number
    subscriptionId?: IntNullableFilter<"Invoice"> | number | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
  }

  export type TicketUpdateManyWithWhereWithoutUserInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: IntFilter<"Ticket"> | number
    userId?: IntFilter<"Ticket"> | number
    subject?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    priority?: StringFilter<"Ticket"> | string
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type TicketMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketMessageWhereUniqueInput
    update: XOR<TicketMessageUpdateWithoutUserInput, TicketMessageUncheckedUpdateWithoutUserInput>
    create: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput>
  }

  export type TicketMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketMessageWhereUniqueInput
    data: XOR<TicketMessageUpdateWithoutUserInput, TicketMessageUncheckedUpdateWithoutUserInput>
  }

  export type TicketMessageUpdateManyWithWhereWithoutUserInput = {
    where: TicketMessageScalarWhereInput
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketMessageScalarWhereInput = {
    AND?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    OR?: TicketMessageScalarWhereInput[]
    NOT?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    id?: IntFilter<"TicketMessage"> | number
    ticketId?: IntFilter<"TicketMessage"> | number
    userId?: IntFilter<"TicketMessage"> | number
    message?: StringFilter<"TicketMessage"> | string
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
  }

  export type OAuthApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: OAuthApplicationWhereUniqueInput
    update: XOR<OAuthApplicationUpdateWithoutUserInput, OAuthApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<OAuthApplicationCreateWithoutUserInput, OAuthApplicationUncheckedCreateWithoutUserInput>
  }

  export type OAuthApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: OAuthApplicationWhereUniqueInput
    data: XOR<OAuthApplicationUpdateWithoutUserInput, OAuthApplicationUncheckedUpdateWithoutUserInput>
  }

  export type OAuthApplicationUpdateManyWithWhereWithoutUserInput = {
    where: OAuthApplicationScalarWhereInput
    data: XOR<OAuthApplicationUpdateManyMutationInput, OAuthApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type OAuthApplicationScalarWhereInput = {
    AND?: OAuthApplicationScalarWhereInput | OAuthApplicationScalarWhereInput[]
    OR?: OAuthApplicationScalarWhereInput[]
    NOT?: OAuthApplicationScalarWhereInput | OAuthApplicationScalarWhereInput[]
    id?: IntFilter<"OAuthApplication"> | number
    name?: StringFilter<"OAuthApplication"> | string
    description?: StringNullableFilter<"OAuthApplication"> | string | null
    website?: StringNullableFilter<"OAuthApplication"> | string | null
    clientId?: StringFilter<"OAuthApplication"> | string
    clientSecret?: StringFilter<"OAuthApplication"> | string
    redirectUris?: StringFilter<"OAuthApplication"> | string
    userId?: IntFilter<"OAuthApplication"> | number
    isActive?: BoolFilter<"OAuthApplication"> | boolean
    createdAt?: DateTimeFilter<"OAuthApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthApplication"> | Date | string
  }

  export type OAuthAuthCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: OAuthAuthCodeWhereUniqueInput
    update: XOR<OAuthAuthCodeUpdateWithoutUserInput, OAuthAuthCodeUncheckedUpdateWithoutUserInput>
    create: XOR<OAuthAuthCodeCreateWithoutUserInput, OAuthAuthCodeUncheckedCreateWithoutUserInput>
  }

  export type OAuthAuthCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: OAuthAuthCodeWhereUniqueInput
    data: XOR<OAuthAuthCodeUpdateWithoutUserInput, OAuthAuthCodeUncheckedUpdateWithoutUserInput>
  }

  export type OAuthAuthCodeUpdateManyWithWhereWithoutUserInput = {
    where: OAuthAuthCodeScalarWhereInput
    data: XOR<OAuthAuthCodeUpdateManyMutationInput, OAuthAuthCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type OAuthAuthCodeScalarWhereInput = {
    AND?: OAuthAuthCodeScalarWhereInput | OAuthAuthCodeScalarWhereInput[]
    OR?: OAuthAuthCodeScalarWhereInput[]
    NOT?: OAuthAuthCodeScalarWhereInput | OAuthAuthCodeScalarWhereInput[]
    id?: IntFilter<"OAuthAuthCode"> | number
    code?: StringFilter<"OAuthAuthCode"> | string
    applicationId?: IntFilter<"OAuthAuthCode"> | number
    userId?: IntFilter<"OAuthAuthCode"> | number
    redirectUri?: StringFilter<"OAuthAuthCode"> | string
    expiresAt?: DateTimeFilter<"OAuthAuthCode"> | Date | string
    used?: BoolFilter<"OAuthAuthCode"> | boolean
    createdAt?: DateTimeFilter<"OAuthAuthCode"> | Date | string
  }

  export type OAuthAccessTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: OAuthAccessTokenWhereUniqueInput
    update: XOR<OAuthAccessTokenUpdateWithoutUserInput, OAuthAccessTokenUncheckedUpdateWithoutUserInput>
    create: XOR<OAuthAccessTokenCreateWithoutUserInput, OAuthAccessTokenUncheckedCreateWithoutUserInput>
  }

  export type OAuthAccessTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: OAuthAccessTokenWhereUniqueInput
    data: XOR<OAuthAccessTokenUpdateWithoutUserInput, OAuthAccessTokenUncheckedUpdateWithoutUserInput>
  }

  export type OAuthAccessTokenUpdateManyWithWhereWithoutUserInput = {
    where: OAuthAccessTokenScalarWhereInput
    data: XOR<OAuthAccessTokenUpdateManyMutationInput, OAuthAccessTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type OAuthAccessTokenScalarWhereInput = {
    AND?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
    OR?: OAuthAccessTokenScalarWhereInput[]
    NOT?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
    id?: IntFilter<"OAuthAccessToken"> | number
    token?: StringFilter<"OAuthAccessToken"> | string
    refreshToken?: StringNullableFilter<"OAuthAccessToken"> | string | null
    applicationId?: IntFilter<"OAuthAccessToken"> | number
    userId?: IntFilter<"OAuthAccessToken"> | number
    scope?: StringNullableFilter<"OAuthAccessToken"> | string | null
    expiresAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
  }

  export type PromoCodeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PromoCodeWhereUniqueInput
    update: XOR<PromoCodeUpdateWithoutCreatorInput, PromoCodeUncheckedUpdateWithoutCreatorInput>
    create: XOR<PromoCodeCreateWithoutCreatorInput, PromoCodeUncheckedCreateWithoutCreatorInput>
  }

  export type PromoCodeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PromoCodeWhereUniqueInput
    data: XOR<PromoCodeUpdateWithoutCreatorInput, PromoCodeUncheckedUpdateWithoutCreatorInput>
  }

  export type PromoCodeUpdateManyWithWhereWithoutCreatorInput = {
    where: PromoCodeScalarWhereInput
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PromoCodeScalarWhereInput = {
    AND?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    OR?: PromoCodeScalarWhereInput[]
    NOT?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    id?: IntFilter<"PromoCode"> | number
    code?: StringFilter<"PromoCode"> | string
    description?: StringNullableFilter<"PromoCode"> | string | null
    discountType?: StringFilter<"PromoCode"> | string
    discountValue?: FloatFilter<"PromoCode"> | number
    maxUses?: IntNullableFilter<"PromoCode"> | number | null
    currentUses?: IntFilter<"PromoCode"> | number
    validFrom?: DateTimeFilter<"PromoCode"> | Date | string
    validUntil?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdBy?: IntFilter<"PromoCode"> | number
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    updatedAt?: DateTimeFilter<"PromoCode"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    category?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutDomainInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDomainInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDomainInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDomainInput, UserUncheckedCreateWithoutDomainInput>
  }

  export type EmailAccountCreateWithoutDomainInput = {
    address: string
    password: string
    storageUsed?: number
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
    owner?: UserCreateNestedOneWithoutEmailAccountsInput
    emails?: EmailCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUncheckedCreateWithoutDomainInput = {
    id?: number
    address: string
    password: string
    storageUsed?: number
    ownerId?: number | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
    emails?: EmailUncheckedCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountCreateOrConnectWithoutDomainInput = {
    where: EmailAccountWhereUniqueInput
    create: XOR<EmailAccountCreateWithoutDomainInput, EmailAccountUncheckedCreateWithoutDomainInput>
  }

  export type EmailAccountCreateManyDomainInputEnvelope = {
    data: EmailAccountCreateManyDomainInput | EmailAccountCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDomainInput = {
    update: XOR<UserUpdateWithoutDomainInput, UserUncheckedUpdateWithoutDomainInput>
    create: XOR<UserCreateWithoutDomainInput, UserUncheckedCreateWithoutDomainInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDomainInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDomainInput, UserUncheckedUpdateWithoutDomainInput>
  }

  export type UserUpdateWithoutDomainInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailAccountUpsertWithWhereUniqueWithoutDomainInput = {
    where: EmailAccountWhereUniqueInput
    update: XOR<EmailAccountUpdateWithoutDomainInput, EmailAccountUncheckedUpdateWithoutDomainInput>
    create: XOR<EmailAccountCreateWithoutDomainInput, EmailAccountUncheckedCreateWithoutDomainInput>
  }

  export type EmailAccountUpdateWithWhereUniqueWithoutDomainInput = {
    where: EmailAccountWhereUniqueInput
    data: XOR<EmailAccountUpdateWithoutDomainInput, EmailAccountUncheckedUpdateWithoutDomainInput>
  }

  export type EmailAccountUpdateManyWithWhereWithoutDomainInput = {
    where: EmailAccountScalarWhereInput
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyWithoutDomainInput>
  }

  export type DomainCreateWithoutEmailAccountsInput = {
    domainName: string
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutDomainInput
  }

  export type DomainUncheckedCreateWithoutEmailAccountsInput = {
    id?: number
    domainName: string
    userId: number
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type DomainCreateOrConnectWithoutEmailAccountsInput = {
    where: DomainWhereUniqueInput
    create: XOR<DomainCreateWithoutEmailAccountsInput, DomainUncheckedCreateWithoutEmailAccountsInput>
  }

  export type UserCreateWithoutEmailAccountsInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailAccountsInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
  }

  export type EmailCreateWithoutAccountInput = {
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
    attachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutAccountInput = {
    id?: number
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
    attachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutAccountInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutAccountInput, EmailUncheckedCreateWithoutAccountInput>
  }

  export type EmailCreateManyAccountInputEnvelope = {
    data: EmailCreateManyAccountInput | EmailCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type DomainUpsertWithoutEmailAccountsInput = {
    update: XOR<DomainUpdateWithoutEmailAccountsInput, DomainUncheckedUpdateWithoutEmailAccountsInput>
    create: XOR<DomainCreateWithoutEmailAccountsInput, DomainUncheckedCreateWithoutEmailAccountsInput>
    where?: DomainWhereInput
  }

  export type DomainUpdateToOneWithWhereWithoutEmailAccountsInput = {
    where?: DomainWhereInput
    data: XOR<DomainUpdateWithoutEmailAccountsInput, DomainUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type DomainUpdateWithoutEmailAccountsInput = {
    domainName?: StringFieldUpdateOperationsInput | string
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutEmailAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutEmailAccountsInput = {
    update: XOR<UserUpdateWithoutEmailAccountsInput, UserUncheckedUpdateWithoutEmailAccountsInput>
    create: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailAccountsInput, UserUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type UserUpdateWithoutEmailAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailUpsertWithWhereUniqueWithoutAccountInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutAccountInput, EmailUncheckedUpdateWithoutAccountInput>
    create: XOR<EmailCreateWithoutAccountInput, EmailUncheckedCreateWithoutAccountInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutAccountInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutAccountInput, EmailUncheckedUpdateWithoutAccountInput>
  }

  export type EmailUpdateManyWithWhereWithoutAccountInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutAccountInput>
  }

  export type EmailScalarWhereInput = {
    AND?: EmailScalarWhereInput | EmailScalarWhereInput[]
    OR?: EmailScalarWhereInput[]
    NOT?: EmailScalarWhereInput | EmailScalarWhereInput[]
    id?: IntFilter<"Email"> | number
    emailAccountId?: IntFilter<"Email"> | number
    from?: StringFilter<"Email"> | string
    to?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    body?: StringFilter<"Email"> | string
    htmlBody?: StringNullableFilter<"Email"> | string | null
    isRead?: BoolFilter<"Email"> | boolean
    isSent?: BoolFilter<"Email"> | boolean
    messageId?: StringNullableFilter<"Email"> | string | null
    inReplyTo?: StringNullableFilter<"Email"> | string | null
    references?: StringNullableFilter<"Email"> | string | null
    priority?: StringNullableFilter<"Email"> | string | null
    receivedAt?: DateTimeFilter<"Email"> | Date | string
    sentAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    isStarred?: BoolFilter<"Email"> | boolean
    isArchived?: BoolFilter<"Email"> | boolean
    isSpam?: BoolFilter<"Email"> | boolean
    isImportant?: BoolFilter<"Email"> | boolean
    isDraft?: BoolFilter<"Email"> | boolean
    isDeleted?: BoolFilter<"Email"> | boolean
    folderId?: IntNullableFilter<"Email"> | number | null
    labels?: StringNullableFilter<"Email"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Email"> | Date | string | null
  }

  export type EmailAccountCreateWithoutEmailsInput = {
    address: string
    password: string
    storageUsed?: number
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
    domain: DomainCreateNestedOneWithoutEmailAccountsInput
    owner?: UserCreateNestedOneWithoutEmailAccountsInput
  }

  export type EmailAccountUncheckedCreateWithoutEmailsInput = {
    id?: number
    address: string
    password: string
    storageUsed?: number
    domainId: number
    ownerId?: number | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
  }

  export type EmailAccountCreateOrConnectWithoutEmailsInput = {
    where: EmailAccountWhereUniqueInput
    create: XOR<EmailAccountCreateWithoutEmailsInput, EmailAccountUncheckedCreateWithoutEmailsInput>
  }

  export type EmailAttachmentCreateWithoutEmailInput = {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    contentId?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentUncheckedCreateWithoutEmailInput = {
    id?: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    contentId?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentCreateOrConnectWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    create: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput>
  }

  export type EmailAttachmentCreateManyEmailInputEnvelope = {
    data: EmailAttachmentCreateManyEmailInput | EmailAttachmentCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type EmailAccountUpsertWithoutEmailsInput = {
    update: XOR<EmailAccountUpdateWithoutEmailsInput, EmailAccountUncheckedUpdateWithoutEmailsInput>
    create: XOR<EmailAccountCreateWithoutEmailsInput, EmailAccountUncheckedCreateWithoutEmailsInput>
    where?: EmailAccountWhereInput
  }

  export type EmailAccountUpdateToOneWithWhereWithoutEmailsInput = {
    where?: EmailAccountWhereInput
    data: XOR<EmailAccountUpdateWithoutEmailsInput, EmailAccountUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailAccountUpdateWithoutEmailsInput = {
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneRequiredWithoutEmailAccountsNestedInput
    owner?: UserUpdateOneWithoutEmailAccountsNestedInput
  }

  export type EmailAccountUncheckedUpdateWithoutEmailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    update: XOR<EmailAttachmentUpdateWithoutEmailInput, EmailAttachmentUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput>
  }

  export type EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    data: XOR<EmailAttachmentUpdateWithoutEmailInput, EmailAttachmentUncheckedUpdateWithoutEmailInput>
  }

  export type EmailAttachmentUpdateManyWithWhereWithoutEmailInput = {
    where: EmailAttachmentScalarWhereInput
    data: XOR<EmailAttachmentUpdateManyMutationInput, EmailAttachmentUncheckedUpdateManyWithoutEmailInput>
  }

  export type EmailAttachmentScalarWhereInput = {
    AND?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
    OR?: EmailAttachmentScalarWhereInput[]
    NOT?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
    id?: IntFilter<"EmailAttachment"> | number
    emailId?: IntFilter<"EmailAttachment"> | number
    fileName?: StringFilter<"EmailAttachment"> | string
    filePath?: StringFilter<"EmailAttachment"> | string
    fileSize?: IntFilter<"EmailAttachment"> | number
    mimeType?: StringFilter<"EmailAttachment"> | string
    contentId?: StringNullableFilter<"EmailAttachment"> | string | null
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
  }

  export type SubscriptionCreateWithoutPlanInput = {
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    user: UserCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: number
    userId: number
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type InvoiceCreateWithoutSubscriptionInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutSubscriptionsInput = {
    name: string
    description?: string | null
    priceMonthly: number
    priceYearly: number
    maxEmails?: number
    maxStorageGB?: number
    maxDomains?: number
    features?: string | null
    category?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    name: string
    description?: string | null
    priceMonthly: number
    priceYearly: number
    maxEmails?: number
    maxStorageGB?: number
    maxDomains?: number
    features?: string | null
    category?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateWithoutSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    maxEmails?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: IntFieldUpdateOperationsInput | number
    maxDomains?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: FloatFieldUpdateOperationsInput | number
    priceYearly?: FloatFieldUpdateOperationsInput | number
    maxEmails?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: IntFieldUpdateOperationsInput | number
    maxDomains?: IntFieldUpdateOperationsInput | number
    features?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutInvoicesInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type SubscriptionCreateWithoutInvoicesInput = {
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    user: UserCreateNestedOneWithoutSubscriptionsInput
    Plan?: PlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id?: number
    userId: number
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    planId?: number | null
  }

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateWithoutInvoicesInput = {
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    Plan?: PlanUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutTicketsInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type TicketAttachmentCreateWithoutTicketInput = {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUncheckedCreateWithoutTicketInput = {
    id?: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type TicketAttachmentCreateOrConnectWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentCreateManyTicketInputEnvelope = {
    data: TicketAttachmentCreateManyTicketInput | TicketAttachmentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketMessageCreateWithoutTicketInput = {
    message: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTicketMessagesInput
  }

  export type TicketMessageUncheckedCreateWithoutTicketInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type TicketMessageCreateOrConnectWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageCreateManyTicketInputEnvelope = {
    data: TicketMessageCreateManyTicketInput | TicketMessageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketAttachmentScalarWhereInput = {
    AND?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    OR?: TicketAttachmentScalarWhereInput[]
    NOT?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    id?: IntFilter<"TicketAttachment"> | number
    ticketId?: IntFilter<"TicketAttachment"> | number
    fileName?: StringFilter<"TicketAttachment"> | string
    filePath?: StringFilter<"TicketAttachment"> | string
    fileSize?: IntFilter<"TicketAttachment"> | number
    mimeType?: StringFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
  }

  export type TicketMessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    update: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    data: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
  }

  export type TicketMessageUpdateManyWithWhereWithoutTicketInput = {
    where: TicketMessageScalarWhereInput
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCreateWithoutAttachmentsInput = {
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    userId: number
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAttachmentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
  }

  export type TicketUpsertWithoutAttachmentsInput = {
    update: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketUpdateWithoutAttachmentsInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateWithoutMessagesInput = {
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsInput
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutMessagesInput = {
    id?: number
    userId: number
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutMessagesInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutTicketMessagesInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketMessagesInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
  }

  export type TicketUpsertWithoutMessagesInput = {
    update: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type TicketUpdateWithoutMessagesInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketMessagesInput = {
    update: XOR<UserUpdateWithoutTicketMessagesInput, UserUncheckedUpdateWithoutTicketMessagesInput>
    create: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketMessagesInput, UserUncheckedUpdateWithoutTicketMessagesInput>
  }

  export type UserUpdateWithoutTicketMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailCreateWithoutAttachmentsInput = {
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
    account: EmailAccountCreateNestedOneWithoutEmailsInput
  }

  export type EmailUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    emailAccountId: number
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
  }

  export type EmailCreateOrConnectWithoutAttachmentsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
  }

  export type EmailUpsertWithoutAttachmentsInput = {
    update: XOR<EmailUpdateWithoutAttachmentsInput, EmailUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutAttachmentsInput, EmailUncheckedUpdateWithoutAttachmentsInput>
  }

  export type EmailUpdateWithoutAttachmentsInput = {
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    account?: EmailAccountUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailAccountId?: IntFieldUpdateOperationsInput | number
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutOauthApplicationsInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthApplicationsInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthApplicationsInput, UserUncheckedCreateWithoutOauthApplicationsInput>
  }

  export type OAuthAuthCodeCreateWithoutApplicationInput = {
    code: string
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOauthAuthCodesInput
  }

  export type OAuthAuthCodeUncheckedCreateWithoutApplicationInput = {
    id?: number
    code: string
    userId: number
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OAuthAuthCodeCreateOrConnectWithoutApplicationInput = {
    where: OAuthAuthCodeWhereUniqueInput
    create: XOR<OAuthAuthCodeCreateWithoutApplicationInput, OAuthAuthCodeUncheckedCreateWithoutApplicationInput>
  }

  export type OAuthAuthCodeCreateManyApplicationInputEnvelope = {
    data: OAuthAuthCodeCreateManyApplicationInput | OAuthAuthCodeCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAccessTokenCreateWithoutApplicationInput = {
    token: string
    refreshToken?: string | null
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOauthAccessTokensInput
  }

  export type OAuthAccessTokenUncheckedCreateWithoutApplicationInput = {
    id?: number
    token: string
    refreshToken?: string | null
    userId: number
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAccessTokenCreateOrConnectWithoutApplicationInput = {
    where: OAuthAccessTokenWhereUniqueInput
    create: XOR<OAuthAccessTokenCreateWithoutApplicationInput, OAuthAccessTokenUncheckedCreateWithoutApplicationInput>
  }

  export type OAuthAccessTokenCreateManyApplicationInputEnvelope = {
    data: OAuthAccessTokenCreateManyApplicationInput | OAuthAccessTokenCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOauthApplicationsInput = {
    update: XOR<UserUpdateWithoutOauthApplicationsInput, UserUncheckedUpdateWithoutOauthApplicationsInput>
    create: XOR<UserCreateWithoutOauthApplicationsInput, UserUncheckedCreateWithoutOauthApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthApplicationsInput, UserUncheckedUpdateWithoutOauthApplicationsInput>
  }

  export type UserUpdateWithoutOauthApplicationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthApplicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OAuthAuthCodeUpsertWithWhereUniqueWithoutApplicationInput = {
    where: OAuthAuthCodeWhereUniqueInput
    update: XOR<OAuthAuthCodeUpdateWithoutApplicationInput, OAuthAuthCodeUncheckedUpdateWithoutApplicationInput>
    create: XOR<OAuthAuthCodeCreateWithoutApplicationInput, OAuthAuthCodeUncheckedCreateWithoutApplicationInput>
  }

  export type OAuthAuthCodeUpdateWithWhereUniqueWithoutApplicationInput = {
    where: OAuthAuthCodeWhereUniqueInput
    data: XOR<OAuthAuthCodeUpdateWithoutApplicationInput, OAuthAuthCodeUncheckedUpdateWithoutApplicationInput>
  }

  export type OAuthAuthCodeUpdateManyWithWhereWithoutApplicationInput = {
    where: OAuthAuthCodeScalarWhereInput
    data: XOR<OAuthAuthCodeUpdateManyMutationInput, OAuthAuthCodeUncheckedUpdateManyWithoutApplicationInput>
  }

  export type OAuthAccessTokenUpsertWithWhereUniqueWithoutApplicationInput = {
    where: OAuthAccessTokenWhereUniqueInput
    update: XOR<OAuthAccessTokenUpdateWithoutApplicationInput, OAuthAccessTokenUncheckedUpdateWithoutApplicationInput>
    create: XOR<OAuthAccessTokenCreateWithoutApplicationInput, OAuthAccessTokenUncheckedCreateWithoutApplicationInput>
  }

  export type OAuthAccessTokenUpdateWithWhereUniqueWithoutApplicationInput = {
    where: OAuthAccessTokenWhereUniqueInput
    data: XOR<OAuthAccessTokenUpdateWithoutApplicationInput, OAuthAccessTokenUncheckedUpdateWithoutApplicationInput>
  }

  export type OAuthAccessTokenUpdateManyWithWhereWithoutApplicationInput = {
    where: OAuthAccessTokenScalarWhereInput
    data: XOR<OAuthAccessTokenUpdateManyMutationInput, OAuthAccessTokenUncheckedUpdateManyWithoutApplicationInput>
  }

  export type OAuthApplicationCreateWithoutAuthCodesInput = {
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOauthApplicationsInput
    accessTokens?: OAuthAccessTokenCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationUncheckedCreateWithoutAuthCodesInput = {
    id?: number
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationCreateOrConnectWithoutAuthCodesInput = {
    where: OAuthApplicationWhereUniqueInput
    create: XOR<OAuthApplicationCreateWithoutAuthCodesInput, OAuthApplicationUncheckedCreateWithoutAuthCodesInput>
  }

  export type UserCreateWithoutOauthAuthCodesInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthAuthCodesInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthAuthCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthAuthCodesInput, UserUncheckedCreateWithoutOauthAuthCodesInput>
  }

  export type OAuthApplicationUpsertWithoutAuthCodesInput = {
    update: XOR<OAuthApplicationUpdateWithoutAuthCodesInput, OAuthApplicationUncheckedUpdateWithoutAuthCodesInput>
    create: XOR<OAuthApplicationCreateWithoutAuthCodesInput, OAuthApplicationUncheckedCreateWithoutAuthCodesInput>
    where?: OAuthApplicationWhereInput
  }

  export type OAuthApplicationUpdateToOneWithWhereWithoutAuthCodesInput = {
    where?: OAuthApplicationWhereInput
    data: XOR<OAuthApplicationUpdateWithoutAuthCodesInput, OAuthApplicationUncheckedUpdateWithoutAuthCodesInput>
  }

  export type OAuthApplicationUpdateWithoutAuthCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthApplicationsNestedInput
    accessTokens?: OAuthAccessTokenUpdateManyWithoutApplicationNestedInput
  }

  export type OAuthApplicationUncheckedUpdateWithoutAuthCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutOauthAuthCodesInput = {
    update: XOR<UserUpdateWithoutOauthAuthCodesInput, UserUncheckedUpdateWithoutOauthAuthCodesInput>
    create: XOR<UserCreateWithoutOauthAuthCodesInput, UserUncheckedCreateWithoutOauthAuthCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthAuthCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthAuthCodesInput, UserUncheckedUpdateWithoutOauthAuthCodesInput>
  }

  export type UserUpdateWithoutOauthAuthCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthAuthCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OAuthApplicationCreateWithoutAccessTokensInput = {
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOauthApplicationsInput
    authCodes?: OAuthAuthCodeCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationUncheckedCreateWithoutAccessTokensInput = {
    id?: number
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type OAuthApplicationCreateOrConnectWithoutAccessTokensInput = {
    where: OAuthApplicationWhereUniqueInput
    create: XOR<OAuthApplicationCreateWithoutAccessTokensInput, OAuthApplicationUncheckedCreateWithoutAccessTokensInput>
  }

  export type UserCreateWithoutOauthAccessTokensInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthAccessTokensInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthAccessTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthAccessTokensInput, UserUncheckedCreateWithoutOauthAccessTokensInput>
  }

  export type OAuthApplicationUpsertWithoutAccessTokensInput = {
    update: XOR<OAuthApplicationUpdateWithoutAccessTokensInput, OAuthApplicationUncheckedUpdateWithoutAccessTokensInput>
    create: XOR<OAuthApplicationCreateWithoutAccessTokensInput, OAuthApplicationUncheckedCreateWithoutAccessTokensInput>
    where?: OAuthApplicationWhereInput
  }

  export type OAuthApplicationUpdateToOneWithWhereWithoutAccessTokensInput = {
    where?: OAuthApplicationWhereInput
    data: XOR<OAuthApplicationUpdateWithoutAccessTokensInput, OAuthApplicationUncheckedUpdateWithoutAccessTokensInput>
  }

  export type OAuthApplicationUpdateWithoutAccessTokensInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthApplicationsNestedInput
    authCodes?: OAuthAuthCodeUpdateManyWithoutApplicationNestedInput
  }

  export type OAuthApplicationUncheckedUpdateWithoutAccessTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutOauthAccessTokensInput = {
    update: XOR<UserUpdateWithoutOauthAccessTokensInput, UserUncheckedUpdateWithoutOauthAccessTokensInput>
    create: XOR<UserCreateWithoutOauthAccessTokensInput, UserUncheckedCreateWithoutOauthAccessTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthAccessTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthAccessTokensInput, UserUncheckedUpdateWithoutOauthAccessTokensInput>
  }

  export type UserUpdateWithoutOauthAccessTokensInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthAccessTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedPromoCodesInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedPromoCodesInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedPromoCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPromoCodesInput, UserUncheckedCreateWithoutCreatedPromoCodesInput>
  }

  export type UserUpsertWithoutCreatedPromoCodesInput = {
    update: XOR<UserUpdateWithoutCreatedPromoCodesInput, UserUncheckedUpdateWithoutCreatedPromoCodesInput>
    create: XOR<UserCreateWithoutCreatedPromoCodesInput, UserUncheckedCreateWithoutCreatedPromoCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPromoCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPromoCodesInput, UserUncheckedUpdateWithoutCreatedPromoCodesInput>
  }

  export type UserUpdateWithoutCreatedPromoCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPromoCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name: string
    email: string
    password: string
    role?: string
    phone?: string | null
    paymentMethod?: string | null
    paymentDetails?: string | null
    recoveryEmail?: string | null
    recoveryPhone?: string | null
    recoveryPhoneCountryCode?: string | null
    allowEmailRecovery?: boolean
    allowPhoneRecovery?: boolean
    allowQRLogin?: boolean
    recoveryPhrase?: string | null
    allowRecoveryPhrase?: boolean
    allowDeviceRecovery?: boolean
    recoveryFileHash?: string | null
    preferences?: string | null
    credits?: number
    appliedGiftCodes?: string | null
    twoPasswordMode?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorSecret?: string | null
    emergencyContacts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Domain?: DomainUncheckedCreateNestedManyWithoutUserInput
    EmailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    oauthApplications?: OAuthApplicationUncheckedCreateNestedManyWithoutUserInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedCreateNestedManyWithoutUserInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutUserInput
    createdPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryPhoneCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    allowEmailRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowPhoneRecovery?: BoolFieldUpdateOperationsInput | boolean
    allowQRLogin?: BoolFieldUpdateOperationsInput | boolean
    recoveryPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    allowRecoveryPhrase?: BoolFieldUpdateOperationsInput | boolean
    allowDeviceRecovery?: BoolFieldUpdateOperationsInput | boolean
    recoveryFileHash?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: FloatFieldUpdateOperationsInput | number
    appliedGiftCodes?: NullableStringFieldUpdateOperationsInput | string | null
    twoPasswordMode?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Domain?: DomainUncheckedUpdateManyWithoutUserNestedInput
    EmailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    oauthApplications?: OAuthApplicationUncheckedUpdateManyWithoutUserNestedInput
    oauthAuthCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutUserNestedInput
    oauthAccessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutUserNestedInput
    createdPromoCodes?: PromoCodeUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DomainCreateManyUserInput = {
    id?: number
    domainName: string
    dnsVerified?: boolean
    mxRecord?: string | null
    spfRecord?: string | null
    dkimRecord?: string | null
    dmarcRecord?: string | null
    lastDnsCheck?: Date | string | null
    smtpProvider?: string | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpApiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type EmailAccountCreateManyOwnerInput = {
    id?: number
    address: string
    password: string
    storageUsed?: number
    domainId: number
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: number
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
    planId?: number | null
  }

  export type InvoiceCreateManyUserInput = {
    id?: number
    subscriptionId?: number | null
    createdAt?: Date | string
  }

  export type TicketCreateManyUserInput = {
    id?: number
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketMessageCreateManyUserInput = {
    id?: number
    ticketId: number
    message: string
    createdAt?: Date | string
  }

  export type OAuthApplicationCreateManyUserInput = {
    id?: number
    name: string
    description?: string | null
    website?: string | null
    clientId: string
    clientSecret: string
    redirectUris: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthAuthCodeCreateManyUserInput = {
    id?: number
    code: string
    applicationId: number
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OAuthAccessTokenCreateManyUserInput = {
    id?: number
    token: string
    refreshToken?: string | null
    applicationId: number
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PromoCodeCreateManyCreatorInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: string
    discountValue: number
    maxUses?: number | null
    currentUses?: number
    validFrom?: Date | string
    validUntil?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: string
    category?: string | null
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type DomainUpdateWithoutUserInput = {
    domainName?: StringFieldUpdateOperationsInput | string
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAccounts?: EmailAccountUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainName?: StringFieldUpdateOperationsInput | string
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type DomainUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    domainName?: StringFieldUpdateOperationsInput | string
    dnsVerified?: BoolFieldUpdateOperationsInput | boolean
    mxRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dkimRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    lastDnsCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    smtpProvider?: NullableStringFieldUpdateOperationsInput | string | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAccountUpdateWithoutOwnerInput = {
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: DomainUpdateOneRequiredWithoutEmailAccountsNestedInput
    emails?: EmailUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    domainId?: IntFieldUpdateOperationsInput | number
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    Plan?: PlanUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InvoiceUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutUserInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthApplicationUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authCodes?: OAuthAuthCodeUpdateManyWithoutApplicationNestedInput
    accessTokens?: OAuthAccessTokenUpdateManyWithoutApplicationNestedInput
  }

  export type OAuthApplicationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authCodes?: OAuthAuthCodeUncheckedUpdateManyWithoutApplicationNestedInput
    accessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type OAuthApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecret?: StringFieldUpdateOperationsInput | string
    redirectUris?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthCodeUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: OAuthApplicationUpdateOneRequiredWithoutAuthCodesNestedInput
  }

  export type OAuthAuthCodeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthCodeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    applicationId?: IntFieldUpdateOperationsInput | number
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: OAuthApplicationUpdateOneRequiredWithoutAccessTokensNestedInput
  }

  export type OAuthAccessTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUpdateWithoutCreatorInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAccountCreateManyDomainInput = {
    id?: number
    address: string
    password: string
    storageUsed?: number
    ownerId?: number | null
    smtpHost?: string | null
    smtpPort?: number | null
    smtpUser?: string | null
    smtpPassword?: string | null
    createdAt?: Date | string
  }

  export type EmailAccountUpdateWithoutDomainInput = {
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutEmailAccountsNestedInput
    emails?: EmailUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateManyWithoutDomainInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    storageUsed?: FloatFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCreateManyAccountInput = {
    id?: number
    from: string
    to: string
    subject: string
    body: string
    htmlBody?: string | null
    isRead?: boolean
    isSent?: boolean
    messageId?: string | null
    inReplyTo?: string | null
    references?: string | null
    priority?: string | null
    receivedAt?: Date | string
    sentAt?: Date | string | null
    isStarred?: boolean
    isArchived?: boolean
    isSpam?: boolean
    isImportant?: boolean
    isDraft?: boolean
    isDeleted?: boolean
    folderId?: number | null
    labels?: string | null
    scheduledFor?: Date | string | null
  }

  export type EmailUpdateWithoutAccountInput = {
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSent?: BoolFieldUpdateOperationsInput | boolean
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    inReplyTo?: NullableStringFieldUpdateOperationsInput | string | null
    references?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isSpam?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableIntFieldUpdateOperationsInput | number | null
    labels?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAttachmentCreateManyEmailInput = {
    id?: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    contentId?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateWithoutEmailInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateWithoutEmailInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateManyWithoutEmailInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    contentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: number
    userId: number
    plan: string
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateManySubscriptionInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type InvoiceUpdateWithoutSubscriptionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentCreateManyTicketInput = {
    id?: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type TicketMessageCreateManyTicketInput = {
    id?: number
    userId: number
    message: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUpdateWithoutTicketInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUpdateWithoutTicketInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthCodeCreateManyApplicationInput = {
    id?: number
    code: string
    userId: number
    redirectUri: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OAuthAccessTokenCreateManyApplicationInput = {
    id?: number
    token: string
    refreshToken?: string | null
    userId: number
    scope?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAuthCodeUpdateWithoutApplicationInput = {
    code?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthAuthCodesNestedInput
  }

  export type OAuthAuthCodeUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthCodeUncheckedUpdateManyWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    redirectUri?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenUpdateWithoutApplicationInput = {
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthAccessTokensNestedInput
  }

  export type OAuthAccessTokenUncheckedUpdateWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenUncheckedUpdateManyWithoutApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DomainCountOutputTypeDefaultArgs instead
     */
    export type DomainCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DomainCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailAccountCountOutputTypeDefaultArgs instead
     */
    export type EmailAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailCountOutputTypeDefaultArgs instead
     */
    export type EmailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCountOutputTypeDefaultArgs instead
     */
    export type TicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthApplicationCountOutputTypeDefaultArgs instead
     */
    export type OAuthApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DomainDefaultArgs instead
     */
    export type DomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DomainDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailAccountDefaultArgs instead
     */
    export type EmailAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailDefaultArgs instead
     */
    export type EmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketDefaultArgs instead
     */
    export type TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketAttachmentDefaultArgs instead
     */
    export type TicketAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketMessageDefaultArgs instead
     */
    export type TicketMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailAttachmentDefaultArgs instead
     */
    export type EmailAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthApplicationDefaultArgs instead
     */
    export type OAuthApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthAuthCodeDefaultArgs instead
     */
    export type OAuthAuthCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthAuthCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthAccessTokenDefaultArgs instead
     */
    export type OAuthAccessTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthAccessTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromoCodeDefaultArgs instead
     */
    export type PromoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromoCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}